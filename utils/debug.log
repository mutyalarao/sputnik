2016-02-08T13:35:35.493Z - info: oServer.serverNamelocal
2016-02-08T13:35:35.498Z - info: THE END
2016-02-08T13:35:35.508Z - info: inside oServer.start().then
2016-02-08T13:35:35.581Z - info: found the database:mydb6
2016-02-08T13:35:35.583Z - info: in openDb.then()
2016-02-08T15:46:15.920Z - info: oServer.serverNamelocal
2016-02-08T15:46:15.924Z - info: THE END
2016-02-08T15:46:15.934Z - info: inside oServer.start().then
2016-02-08T15:46:16.008Z - info: found the database:mydb6
2016-02-08T15:46:16.010Z - info: in openDb.then()
2016-02-08T15:49:20.697Z - info: oServer.serverNamelocal
2016-02-08T15:49:20.701Z - info: THE END
2016-02-08T15:49:20.711Z - info: inside oServer.start().then
2016-02-08T15:49:20.782Z - info: found the database:mydb6
2016-02-08T15:49:20.784Z - info: in openDb.then()
2016-02-08T15:52:11.470Z - info: oServer.serverNamelocal
2016-02-08T15:52:11.476Z - info: THE END
2016-02-08T15:52:11.489Z - info: inside oServer.start().then
2016-02-08T15:52:11.604Z - info: found the database:mydb6
2016-02-08T15:52:11.606Z - info: in openDb.then()
2016-02-08T16:00:49.639Z - info: oServer.serverNamelocal
2016-02-08T16:00:49.645Z - info: THE END
2016-02-08T16:00:49.655Z - info: inside oServer.start().then
2016-02-08T16:00:49.751Z - info: found the database:mydb6
2016-02-08T16:00:49.753Z - info: in openDb.then()
2016-02-08T16:01:57.249Z - info: oServer.serverNamelocal
2016-02-08T16:01:57.254Z - info: THE END
2016-02-08T16:01:57.263Z - info: inside oServer.start().then
2016-02-08T16:01:57.366Z - info: found the database:mydb6
2016-02-08T16:01:57.368Z - info: in openDb.then()
2016-02-08T16:04:11.294Z - info: oServer.serverNamelocal
2016-02-08T16:04:11.298Z - info: THE END
2016-02-08T16:04:11.308Z - info: inside oServer.start().then
2016-02-08T16:04:11.411Z - info: found the database:mydb6
2016-02-08T16:04:11.413Z - info: in openDb.then()
2016-02-08T16:06:51.654Z - info: oServer.serverNamelocal
2016-02-08T16:06:51.660Z - info: THE END
2016-02-08T16:06:51.673Z - info: inside oServer.start().then
2016-02-08T16:06:51.781Z - info: found the database:mydb6
2016-02-08T16:06:51.783Z - info: in openDb.then()
2016-02-08T16:08:05.906Z - info: oServer.serverNamelocal
2016-02-08T16:08:05.912Z - info: THE END
2016-02-08T16:08:05.921Z - info: inside oServer.start().then
2016-02-08T16:08:06.025Z - info: found the database:mydb6
2016-02-08T16:08:06.029Z - info: in openDb.then()
2016-02-08T16:09:24.995Z - info: oServer.serverNamelocal
2016-02-08T16:09:25.000Z - info: THE END
2016-02-08T16:09:25.010Z - info: inside oServer.start().then
2016-02-08T16:09:25.113Z - info: found the database:mydb6
2016-02-08T16:09:25.115Z - info: in openDb.then()
2016-02-08T16:10:03.249Z - info: oServer.serverNamelocal
2016-02-08T16:10:03.254Z - info: THE END
2016-02-08T16:10:03.266Z - info: inside oServer.start().then
2016-02-08T16:10:03.373Z - info: found the database:mydb6
2016-02-08T16:10:03.375Z - info: in openDb.then()
2016-02-08T16:12:01.914Z - info: oServer.serverNamelocal
2016-02-08T16:12:01.922Z - info: THE END
2016-02-08T16:12:01.935Z - info: inside oServer.start().then
2016-02-08T16:12:01.940Z - info: in init exception...
2016-02-08T16:12:02.014Z - info: found the database:mydb6
2016-02-08T16:12:02.023Z - info: in openDb.then()
2016-02-08T16:16:09.854Z - info: oServer.serverNamelocal
2016-02-08T16:16:09.861Z - info: THE END
2016-02-08T16:16:09.877Z - info: inside oServer.start().then
2016-02-08T16:16:09.884Z - info: in init exception...
2016-02-08T16:16:09.885Z - error: Failed: - Error: NJS-006: invalid type for parameter 1
2016-02-08T16:16:09.965Z - info: found the database:mydb6
2016-02-08T16:16:09.971Z - info: in openDb.then()
2016-02-08T16:17:14.547Z - info: oServer.serverNamelocal
2016-02-08T16:17:14.556Z - info: THE END
2016-02-08T16:17:14.565Z - info: inside oServer.start().then
2016-02-08T16:17:14.570Z - info: in init exception...
2016-02-08T16:17:14.571Z - error: Failed: - Error: NJS-006: invalid type for parameter 1
2016-02-08T16:17:14.638Z - info: found the database:mydb6
2016-02-08T16:17:14.640Z - info: in openDb.then()
2016-02-08T16:20:04.955Z - info: oServer.serverNamelocal
2016-02-08T16:20:04.959Z - info: THE END
2016-02-08T16:20:04.972Z - info: inside oServer.start().then
2016-02-08T16:20:04.978Z - info: in init exception...
2016-02-08T16:20:04.978Z - error: Failed: - Error: NJS-006: invalid type for parameter 1
2016-02-08T16:20:05.046Z - info: found the database:mydb6
2016-02-08T16:20:05.048Z - info: in openDb.then()
2016-02-08T16:24:32.626Z - info: oServer.serverNamelocal
2016-02-08T16:24:32.632Z - info: THE END
2016-02-08T16:24:32.656Z - info: inside oServer.start().then
2016-02-08T16:24:32.661Z - info: in init exception...
2016-02-08T16:24:32.661Z - error: Failed: - Error: NJS-006: invalid type for parameter 1
2016-02-08T16:24:32.731Z - info: found the database:mydb6
2016-02-08T16:24:32.734Z - info: in openDb.then()
2016-02-08T16:25:27.030Z - info: oServer.serverNamelocal
2016-02-08T16:25:27.034Z - info: THE END
2016-02-08T16:25:27.091Z - info: inside oServer.start().then
2016-02-08T16:25:27.167Z - info: found the database:mydb6
2016-02-08T16:25:27.168Z - info: in openDb.then()
2016-02-08T16:26:08.371Z - info: oServer.serverNamelocal
2016-02-08T16:26:08.379Z - info: THE END
2016-02-08T16:26:08.394Z - info: inside oServer.start().then
2016-02-08T16:26:08.454Z - info: found the database:mydb6
2016-02-08T16:26:08.456Z - info: in openDb.then()
2016-02-08T16:26:11.147Z - info: build success
2016-02-08T16:26:26.495Z - info: 10
2016-02-08T16:30:10.452Z - info: oServer.serverNamelocal
2016-02-08T16:30:10.456Z - info: THE END
2016-02-08T16:30:10.466Z - info: inside oServer.start().then
2016-02-08T16:30:10.470Z - info: in init exception...
2016-02-08T16:30:10.471Z - error: Failed: - Error: NJS-006: invalid type for parameter 1
2016-02-08T16:30:10.540Z - info: found the database:mydb6
2016-02-08T16:30:10.541Z - info: in openDb.then()
2016-02-09T07:07:08.669Z - info: oServer.serverNamelocal
2016-02-09T07:07:08.673Z - info: THE END
2016-02-09T07:07:08.684Z - info: inside oServer.start().then
2016-02-09T07:07:08.759Z - info: found the database:mydb6
2016-02-09T07:07:08.761Z - info: in openDb.then()
2016-02-09T07:07:10.126Z - info: build success
2016-02-09T07:07:18.246Z - info: 11
2016-02-09T09:22:00.737Z - info: oServer.serverNamelocal
2016-02-09T09:22:00.742Z - info: THE END
2016-02-09T09:22:00.791Z - info: inside oServer.start().then
2016-02-09T09:22:07.431Z - info: found the database:mydb6
2016-02-09T09:22:07.434Z - info: in openDb.then()
2016-02-09T09:22:08.110Z - info: oServer.serverNamelocal
2016-02-09T09:22:08.118Z - info: THE END
2016-02-09T09:22:08.129Z - info: inside oServer.start().then
2016-02-09T09:22:08.517Z - info: found the database:mydb6
2016-02-09T09:22:08.519Z - info: in openDb.then()
2016-02-09T09:22:09.630Z - info: built sqls successfully
2016-02-09T09:22:09.632Z - info: built sqls successfully
2016-02-09T09:22:09.633Z - info: in processVertices
2016-02-09T09:22:09.637Z - info:  oracleServerVersion=1102000400, action=null, module=null, clientId=null, stmtCacheSize=30, vFile=, eFile=, , vArr=[class=psrecdefn, src=psrecdefn, alias=records, pkey=[recname], attrib=[rectype], sql=SELECT recname,rectype,descrlong,lastupddttm,lastupdoprid,objectownerid FROM psrecdefn, class=psdbfield, src=psdbfield, alias=psdbfield, pkey=[fieldname], attrib=[fieldtype, length], sql=SELECT fieldname,fieldtype,length,descrlong,lastupddttm,lastupdoprid,objectownerid FROM psdbfield], delim=,, objType=, vFilePath=vertex_schema.json, commonAttrib=[descrlong, lastupddttm, lastupdoprid, objectownerid]
2016-02-09T09:22:09.638Z - info: in execsql
2016-02-09T09:22:09.639Z - info: in execsql
2016-02-09T09:22:09.631Z - info: in processVertices
2016-02-09T09:22:09.635Z - info:  oracleServerVersion=1102000400, action=null, module=null, clientId=null, stmtCacheSize=30, vFile=, eFile=, , vArr=[class=psrecdefn, src=psrecdefn, alias=records, pkey=[recname], attrib=[rectype], sql=SELECT recname,rectype,descrlong,lastupddttm,lastupdoprid,objectownerid FROM psrecdefn, class=psdbfield, src=psdbfield, alias=psdbfield, pkey=[fieldname], attrib=[fieldtype, length], sql=SELECT fieldname,fieldtype,length,descrlong,lastupddttm,lastupdoprid,objectownerid FROM psdbfield], delim=,, objType=, vFilePath=vertex_schema.json, commonAttrib=[descrlong, lastupddttm, lastupdoprid, objectownerid]
2016-02-09T09:22:09.637Z - info: in execsql
2016-02-09T09:22:09.637Z - info: in execsql
2016-02-09T09:22:19.081Z - info: 11
2016-02-09T09:22:19.743Z - info: 11
2016-02-09T09:56:28.628Z - info: oServer.serverNamelocal
2016-02-09T09:56:28.632Z - info: THE END
2016-02-09T09:56:28.642Z - info: inside oServer.start().then
2016-02-09T09:56:29.020Z - info: found the database:mydb6
2016-02-09T09:56:29.023Z - info: in openDb.then()
2016-02-09T13:09:08.773Z - info: oServer.serverNamelocal
2016-02-09T13:09:08.779Z - info: THE END
2016-02-09T13:09:08.791Z - info: inside oServer.start().then
2016-02-09T13:09:08.850Z - info: found the database:mydb6
2016-02-09T13:09:08.851Z - info: in openDb.then()
2016-02-09T13:09:09.348Z - info: before addVertexClasses
2016-02-09T13:12:46.975Z - info: oServer.serverNamelocal
2016-02-09T13:12:46.979Z - info: THE END
2016-02-09T13:12:46.988Z - info: inside oServer.start().then
2016-02-09T13:12:47.086Z - info: found the database:mydb6
2016-02-09T13:12:47.088Z - info: in openDb.then()
2016-02-09T13:12:47.756Z - info: before addVertexClasses
2016-02-09T13:13:41.946Z - info: oServer.serverNamelocal
2016-02-09T13:13:41.953Z - info: THE END
2016-02-09T13:13:41.967Z - info: inside oServer.start().then
2016-02-09T13:13:42.050Z - info: found the database:mydb6
2016-02-09T13:13:42.052Z - info: in openDb.then()
2016-02-09T13:13:42.055Z - info: before addVertexClasses
2016-02-09T13:20:29.743Z - info: oServer.serverNamelocal
2016-02-09T13:20:29.753Z - info: THE END
2016-02-09T13:20:29.767Z - info: inside oServer.start().then
2016-02-09T13:20:29.850Z - info: found the database:mydb6
2016-02-09T13:20:29.853Z - info: in openDb.then()
2016-02-09T13:20:29.855Z - info: before addVertexClasses
2016-02-09T13:24:33.591Z - info: oServer.serverNamelocal
2016-02-09T13:24:33.598Z - info: THE END
2016-02-09T13:24:33.618Z - info: inside oServer.start().then
2016-02-09T13:24:33.725Z - info: found the database:mydb6
2016-02-09T13:24:33.726Z - info: in openDb.then()
2016-02-09T13:24:33.730Z - info: before addVertexClasses
2016-02-09T13:25:58.709Z - info: oServer.serverNamelocal
2016-02-09T13:25:58.713Z - info: THE END
2016-02-09T13:25:58.723Z - info: inside oServer.start().then
2016-02-09T13:25:58.820Z - info: found the database:mydb6
2016-02-09T13:26:39.353Z - info: oServer.serverNamelocal
2016-02-09T13:26:39.357Z - info: THE END
2016-02-09T13:26:39.367Z - info: inside oServer.start().then
2016-02-09T13:26:39.434Z - info: found the database:mydb6
2016-02-09T13:26:39.462Z - info: in openDb.then()
2016-02-09T13:26:39.465Z - info: before addVertexClasses
2016-02-09T14:07:20.765Z - info: oServer.serverNamelocal
2016-02-09T14:07:20.770Z - info: THE END
2016-02-09T14:07:20.781Z - info: inside oServer.start().then
2016-02-09T14:07:20.858Z - info: found the database:mydb6
2016-02-09T14:07:20.877Z - info: in openDb.then()
2016-02-09T14:07:20.880Z - info: before addVertexClasses
2016-02-09T14:09:20.469Z - info: oServer.serverNamelocal
2016-02-09T14:09:20.479Z - info: THE END
2016-02-09T14:09:20.493Z - info: inside oServer.start().then
2016-02-09T14:09:20.568Z - info: found the database:mydb6
2016-02-09T14:09:20.621Z - info: in openDb.then()
2016-02-09T14:09:20.623Z - info: before addVertexClasses
2016-02-09T14:09:20.623Z - info: entered addVertexClasses
2016-02-09T14:09:49.232Z - info: oServer.serverNamelocal
2016-02-09T14:09:49.236Z - info: THE END
2016-02-09T14:09:49.245Z - info: inside oServer.start().then
2016-02-09T14:09:49.327Z - info: found the database:mydb6
2016-02-09T14:09:49.345Z - info: in openDb.then()
2016-02-09T14:09:49.351Z - info: before addVertexClasses
2016-02-09T14:09:49.351Z - info: entered addVertexClasses
2016-02-09T14:10:23.792Z - info: oServer.serverNamelocal
2016-02-09T14:10:23.796Z - info: THE END
2016-02-09T14:10:23.807Z - info: inside oServer.start().then
2016-02-09T14:10:23.875Z - info: found the database:mydb6
2016-02-09T14:10:23.891Z - info: in openDb.then()
2016-02-09T14:10:23.894Z - info: before addVertexClasses
2016-02-09T14:10:23.894Z - info: entered addVertexClasses
2016-02-09T14:12:44.206Z - info: oServer.serverNamelocal
2016-02-09T14:12:44.210Z - info: THE END
2016-02-09T14:12:44.221Z - info: inside oServer.start().then
2016-02-09T14:12:44.304Z - info: found the database:mydb6
2016-02-09T14:12:44.322Z - info: in openDb.then()
2016-02-09T14:12:44.324Z - info: before addVertexClasses
2016-02-09T14:12:44.324Z - info: entered addVertexClasses
2016-02-09T14:18:44.015Z - info: oServer.serverNamelocal
2016-02-09T14:18:44.019Z - info: THE END
2016-02-09T14:18:44.034Z - info: inside oServer.start().then
2016-02-09T14:18:44.106Z - info: found the database:mydb6
2016-02-09T14:18:44.128Z - info: in openDb.then()
2016-02-09T14:18:44.131Z - info: before addVertexClasses
2016-02-09T14:18:44.131Z - info: entered addVertexClasses
2016-02-09T14:19:09.413Z - info: oServer.serverNamelocal
2016-02-09T14:19:09.418Z - info: THE END
2016-02-09T14:19:09.428Z - info: inside oServer.start().then
2016-02-09T14:19:09.499Z - info: found the database:mydb6
2016-02-09T14:19:09.554Z - info: in openDb.then()
2016-02-09T14:19:09.556Z - info: before addVertexClasses
2016-02-09T14:19:09.557Z - info: entered addVertexClasses
2016-02-09T14:21:25.266Z - info: oServer.serverNamelocal
2016-02-09T14:21:25.275Z - info: THE END
2016-02-09T14:21:25.286Z - info: inside oServer.start().then
2016-02-09T14:21:25.362Z - info: found the database:mydb6
2016-02-09T14:21:25.379Z - info: in openDb.then()
2016-02-09T14:21:25.381Z - info: before addVertexClasses
2016-02-09T14:21:25.381Z - info: entered addVertexClasses
2016-02-09T14:21:25.382Z - info: in createClass method-psrecdefn
2016-02-09T14:21:25.384Z - info: in createClass method-psdbfield
2016-02-09T14:21:25.384Z - info: testing...
2016-02-09T14:21:25.385Z - info:  , 
2016-02-09T14:21:29.046Z - info: create class for all vertices complete
2016-02-09T14:21:29.047Z - info: addVertexClasses complete
2016-02-09T14:21:29.049Z - info: built sqls successfully
2016-02-09T14:21:29.050Z - info: in processVertices
2016-02-09T14:21:29.174Z - info:  oracleServerVersion=1102000400, action=null, module=null, clientId=null, stmtCacheSize=30, vFile=, eFile=, , vArr=[class=psrecdefn, src=psrecdefn, alias=records, pkey=[recname], attrib=[rectype], sql=SELECT recname,rectype,descrlong,lastupddttm,lastupdoprid,objectownerid FROM psrecdefn, class=psdbfield, src=psdbfield, alias=psdbfield, pkey=[fieldname], attrib=[fieldtype, length], sql=SELECT fieldname,fieldtype,length,descrlong,lastupddttm,lastupdoprid,objectownerid FROM psdbfield], delim=,, objType=, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["oServer"]["server"]["transport"], $ref=$["oServer"]["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=87, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["oServer"]["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=21359, _bytesDispatched=434, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["oServer"]["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], error=function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, _eventsCount=2, _maxListeners=Infinity, serverName=local, dbName=, schemaFilePath=orient_connect.json, name=local, host=localhost, port=2424, username=root, password=root, dbList=[sessionId=-1, forcePrepare=true, name=mydb6, $ref=$["oServer"]["server"], type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }, sessionId=-1, forcePrepare=true, name=GratefulDeadConcerts, $ref=$["oServer"]["server"], type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }, sessionId=-1, forcePrepare=true, name=mydb, $ref=$["oServer"]["server"], type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }, sessionId=-1, forcePrepare=true, name=sptnk_t2, $ref=$["oServer"]["server"], type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }, sessionId=-1, forcePrepare=true, name=mydb1, $ref=$["oServer"]["server"], type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }], sessionId=87, forcePrepare=true, name=mydb6, $ref=$["oServer"]["server"], type=graph, storage=plocal, , useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , name=internal, id=0, name=index, id=1, name=manindex, id=2, name=default, id=3, name=orole, id=4, name=ouser, id=5, name=ofunction, id=6, name=oschedule, id=7, name=orids, id=8, name=v, id=9, name=e, id=10, name=_studio, id=11, $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["4"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["2"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["11"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["5"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["3"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["9"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["1"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["6"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["8"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["10"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["7"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["0"], items=[$ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["4"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["2"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["11"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["5"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["3"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["9"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["1"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["6"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["8"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["10"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["7"], $ref=$["oServer"]["db"]["cluster"]["cached"]["ids"]["0"]], list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OSchedule, shortName=null, defaultClusterId=7, clusterIds=[7], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OSchedule"], name=arguments, originalName=arguments, type=12, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OSchedule"], name=name, originalName=name, type=7, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OSchedule"], name=start, originalName=start, type=0, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OSchedule"], name=status, originalName=status, type=7, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OSchedule"], name=function, originalName=function, type=13, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=OFunction, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OSchedule"], name=starttime, originalName=starttime, type=6, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OSchedule"], name=rule, originalName=rule, type=7, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=null], superClass=null, originalName=OSchedule, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=ORole, shortName=null, defaultClusterId=4, clusterIds=[4], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORole"], name=name, originalName=name, type=7, mandatory=true, readonly=false, notNull=true, collate=ci, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORole"], name=mode, originalName=mode, type=17, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORole"], name=rules, originalName=rules, type=12, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORole"], name=inheritedRole, originalName=inheritedRole, type=13, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=ORole], superClass=OIdentity, originalName=ORole, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=ORIDs, shortName=null, defaultClusterId=8, clusterIds=[8], properties=[], superClass=null, originalName=ORIDs, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OUser, shortName=null, defaultClusterId=5, clusterIds=[5], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OUser"], name=name, originalName=name, type=7, mandatory=true, readonly=false, notNull=true, collate=ci, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OUser"], name=password, originalName=password, type=7, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OUser"], name=roles, originalName=roles, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=ORole, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OUser"], name=status, originalName=status, type=7, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=null], superClass=OIdentity, originalName=OUser, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=V, shortName=null, defaultClusterId=9, clusterIds=[9], properties=[], superClass=null, originalName=V, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=E, shortName=null, defaultClusterId=10, clusterIds=[10], properties=[], superClass=null, originalName=E, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=psrecdefn, shortName=null, defaultClusterId=12, clusterIds=[12], properties=[], superClass=V, originalName=psrecdefn, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OIdentity, shortName=null, defaultClusterId=-1, clusterIds=[-1], properties=[], superClass=null, originalName=OIdentity, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=_studio, shortName=null, defaultClusterId=11, clusterIds=[11], properties=[], superClass=null, originalName=_studio, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=psdbfield, shortName=null, defaultClusterId=13, clusterIds=[13], properties=[], superClass=V, originalName=psdbfield, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OTriggered, shortName=null, defaultClusterId=-1, clusterIds=[-1], properties=[], superClass=null, originalName=OTriggered, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=ORestricted, shortName=null, defaultClusterId=-1, clusterIds=[-1], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORestricted"], name=_allow, originalName=_allow, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=OIdentity, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORestricted"], name=_allowRead, originalName=_allowRead, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=OIdentity, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORestricted"], name=_allowUpdate, originalName=_allowUpdate, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=OIdentity, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORestricted"], name=_allowDelete, originalName=_allowDelete, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=OIdentity], superClass=null, originalName=ORestricted, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OFunction, shortName=null, defaultClusterId=6, clusterIds=[6], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OFunction"], name=language, originalName=language, type=7, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OFunction"], name=code, originalName=code, type=7, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OFunction"], name=name, originalName=name, type=7, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OFunction"], name=idempotent, originalName=idempotent, type=0, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OFunction"], name=parameters, originalName=parameters, type=10, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null], superClass=null, originalName=OFunction, items=[$ref=$["oServer"]["db"]["class"]["cached"]["names"]["OSchedule"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORole"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORIDs"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OUser"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["V"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["E"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["psrecdefn"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OIdentity"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["_studio"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["psdbfield"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OTriggered"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["ORestricted"], $ref=$["oServer"]["db"]["class"]["cached"]["names"]["OFunction"]], list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, serverCluster=null, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }, classList=[list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OIdentity, shortName=null, defaultClusterId=-1, clusterIds=[-1], properties=[], superClass=null, originalName=OIdentity, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=E, shortName=null, defaultClusterId=10, clusterIds=[10], properties=[], superClass=null, originalName=E, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=ORole, shortName=null, defaultClusterId=4, clusterIds=[4], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][2], name=inheritedRole, originalName=inheritedRole, type=13, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=ORole, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][2], name=mode, originalName=mode, type=17, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][2], name=rules, originalName=rules, type=12, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][2], name=name, originalName=name, type=7, mandatory=true, readonly=false, notNull=true, collate=ci, min=null, max=null, regexp=null, linkedClass=null], superClass=OIdentity, originalName=ORole, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OFunction, shortName=null, defaultClusterId=6, clusterIds=[6], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][3], name=idempotent, originalName=idempotent, type=0, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][3], name=code, originalName=code, type=7, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][3], name=parameters, originalName=parameters, type=10, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][3], name=name, originalName=name, type=7, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][3], name=language, originalName=language, type=7, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null], superClass=null, originalName=OFunction, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OSchedule, shortName=null, defaultClusterId=7, clusterIds=[7], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][4], name=arguments, originalName=arguments, type=12, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][4], name=function, originalName=function, type=13, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=OFunction, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][4], name=name, originalName=name, type=7, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][4], name=rule, originalName=rule, type=7, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][4], name=start, originalName=start, type=0, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][4], name=status, originalName=status, type=7, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][4], name=starttime, originalName=starttime, type=6, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=null], superClass=null, originalName=OSchedule, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=V, shortName=null, defaultClusterId=9, clusterIds=[9], properties=[], superClass=null, originalName=V, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=ORestricted, shortName=null, defaultClusterId=-1, clusterIds=[-1], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][6], name=_allowUpdate, originalName=_allowUpdate, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=OIdentity, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][6], name=_allowDelete, originalName=_allowDelete, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=OIdentity, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][6], name=_allowRead, originalName=_allowRead, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=OIdentity, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][6], name=_allow, originalName=_allow, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=OIdentity], superClass=null, originalName=ORestricted, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OUser, shortName=null, defaultClusterId=5, clusterIds=[5], properties=[fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][7], name=password, originalName=password, type=7, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][7], name=status, originalName=status, type=7, mandatory=true, readonly=false, notNull=true, collate=default, min=null, max=null, regexp=null, linkedClass=null, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][7], name=roles, originalName=roles, type=15, mandatory=false, readonly=false, notNull=false, collate=default, min=null, max=null, regexp=null, linkedClass=ORole, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["classList"][7], name=name, originalName=name, type=7, mandatory=true, readonly=false, notNull=true, collate=ci, min=null, max=null, regexp=null, linkedClass=null], superClass=OIdentity, originalName=OUser, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=ORIDs, shortName=null, defaultClusterId=8, clusterIds=[8], properties=[], superClass=null, originalName=ORIDs, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=_studio, shortName=null, defaultClusterId=11, clusterIds=[11], properties=[], superClass=null, originalName=_studio, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, alter=function () { [native code] }, rename=function () { [native code] }, fields=null, valueOf=function () { [native code] }, get=function () { [native code] }, set=function () { [native code] }, unset=function () { [native code] }, $ref=$["oServer"]["db"], name=OTriggered, shortName=null, defaultClusterId=-1, clusterIds=[-1], properties=[], superClass=null, originalName=OTriggered], vFilePath=vertex_schema.json, commonAttrib=[descrlong, lastupddttm, lastupdoprid, objectownerid]
2016-02-09T14:21:29.186Z - info: in execsql
2016-02-09T14:21:29.186Z - info: in execsql
2016-02-09T14:21:35.781Z - info: 11
2016-02-09T14:23:57.779Z - info: oServer.serverNamelocal
2016-02-09T14:23:57.785Z - info: THE END
2016-02-09T14:23:57.797Z - info: inside oServer.start().then
2016-02-09T14:23:57.885Z - info: found the database:mydb6
2016-02-09T14:23:57.906Z - info: in openDb.then()
2016-02-09T14:23:57.909Z - info: before addVertexClasses
2016-02-09T14:23:57.910Z - info: entered addVertexClasses
2016-02-09T14:23:57.911Z - info: testing...
2016-02-09T14:23:57.911Z - info:  , 
2016-02-09T14:23:57.912Z - info: create class for all vertices complete
2016-02-09T14:23:57.912Z - info: addVertexClasses complete
2016-02-09T14:23:57.913Z - info: built sqls successfully
2016-02-09T14:23:57.913Z - info: in processVertices
2016-02-09T14:23:57.914Z - info: in execsql
2016-02-09T14:23:57.914Z - info: in execsql
2016-02-09T14:24:02.580Z - info: 13
2016-02-09T16:57:47.904Z - info: oServer.serverNamelocal
2016-02-09T16:57:47.908Z - info: THE END
2016-02-09T16:57:47.917Z - info: inside oServer.start().then
2016-02-09T16:57:48.026Z - info: found the database:mydb6
2016-02-09T16:57:48.041Z - info: in openDb.then()
2016-02-09T16:57:48.044Z - info: before addVertexClasses
2016-02-09T16:57:48.044Z - info: entered addVertexClasses
2016-02-09T16:57:48.045Z - info: testing...
2016-02-09T16:57:48.046Z - info:  , 
2016-02-09T16:57:48.046Z - info: create class for all vertices complete
2016-02-09T16:57:48.046Z - info: addVertexClasses complete
2016-02-09T16:57:48.047Z - info: built sqls successfully
2016-02-09T16:57:48.048Z - info: in processVertices
2016-02-09T16:57:48.048Z - info: in execsql
2016-02-09T16:57:48.064Z - info: in execsql
2016-02-09T16:57:53.615Z - info: 13
2016-02-09T17:00:31.537Z - info: oServer.serverNamelocal
2016-02-09T17:00:31.542Z - info: THE END
2016-02-09T17:00:31.551Z - info: inside oServer.start().then
2016-02-09T17:00:31.627Z - info: database mydb6 not found. Creating one
2016-02-09T17:00:43.156Z - info: created db=mydb6
2016-02-09T17:00:43.157Z - info: database created:undefined
2016-02-09T17:47:13.679Z - info: oServer.serverNamelocal
2016-02-09T17:47:13.684Z - info: THE END
2016-02-09T17:47:13.696Z - info: inside oServer.start().then
2016-02-09T17:47:13.774Z - info: database mydb6 not found. Creating one
2016-02-09T17:47:22.734Z - info: created db=mydb6
2016-02-09T17:47:22.734Z - info: database created:mydb6
2016-02-09T17:56:18.839Z - info: oServer.serverNamelocal
2016-02-09T17:56:18.847Z - info: THE END
2016-02-09T17:56:18.866Z - info: inside oServer.start().then
2016-02-09T17:56:18.960Z - info: found the database:mydb6
2016-02-09T17:56:18.964Z - info: in openDb.then()
2016-02-09T17:56:18.967Z - info: before addVertexClasses
2016-02-09T17:56:18.967Z - info: entered addVertexClasses
2016-02-09T17:57:58.293Z - info: oServer.serverNamelocal
2016-02-09T17:57:58.300Z - info: THE END
2016-02-09T17:57:58.316Z - info: inside oServer.start().then
2016-02-09T17:57:58.388Z - info: found the database:mydb6
2016-02-09T17:57:58.389Z - info: undefined
2016-02-09T17:57:58.391Z - info: in openDb.then()
2016-02-09T17:57:58.394Z - info: before addVertexClasses
2016-02-09T17:57:58.394Z - info: entered addVertexClasses
2016-02-09T17:58:43.555Z - info: oServer.serverNamelocal
2016-02-09T17:58:43.565Z - info: THE END
2016-02-09T17:58:43.577Z - info: inside oServer.start().then
2016-02-09T17:58:43.651Z - info: database mydb6 not found. Creating one
2016-02-09T17:58:52.111Z - info: created db=mydb6
2016-02-09T17:58:52.140Z - info:  sessionId=150, forcePrepare=true, name=mydb6, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["server"]["transport"], $ref=$["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=150, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=334, _bytesDispatched=110, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], _eventsCount=1, _maxListeners=Infinity, type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }
2016-02-09T17:58:52.143Z - info: database created:mydb6
2016-02-09T17:58:52.163Z - info: in openDb.then()
2016-02-09T17:58:52.166Z - info: before addVertexClasses
2016-02-09T17:58:52.166Z - info: entered addVertexClasses
2016-02-09T17:58:52.170Z - info: testing...
2016-02-09T17:58:52.170Z - info:  , 
2016-02-09T18:02:34.142Z - info: oServer.serverNamelocal
2016-02-09T18:02:34.149Z - info: THE END
2016-02-09T18:02:34.169Z - info: inside oServer.start().then
2016-02-09T18:02:34.268Z - info: database mydb6 not found. Creating one
2016-02-09T18:02:43.572Z - info: created db=mydb6
2016-02-09T18:02:43.598Z - info:  sessionId=158, forcePrepare=true, name=mydb6, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["server"]["transport"], $ref=$["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=158, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=334, _bytesDispatched=110, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], _eventsCount=1, _maxListeners=Infinity, type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }
2016-02-09T18:02:43.604Z - info: database created:mydb6
2016-02-09T18:02:43.648Z - info: in openDb.then()
2016-02-09T18:02:43.652Z - info: before addVertexClasses
2016-02-09T18:02:43.653Z - info: entered addVertexClasses
2016-02-09T18:02:43.658Z - info: testing...
2016-02-09T18:02:43.658Z - info:  , 
2016-02-09T18:08:06.103Z - info: oServer.serverNamelocal
2016-02-09T18:08:06.106Z - info: THE END
2016-02-09T18:08:06.118Z - info: inside oServer.start().then
2016-02-09T18:08:06.218Z - info: database mydb6 not found. Creating one
2016-02-09T18:08:17.148Z - info: created db=mydb6
2016-02-09T18:08:17.169Z - info:  sessionId=168, forcePrepare=true, name=mydb6, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["server"]["transport"], $ref=$["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=168, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=334, _bytesDispatched=110, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], _eventsCount=1, _maxListeners=Infinity, type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }
2016-02-09T18:08:17.173Z - info: database created:mydb6
2016-02-09T18:08:17.198Z - info: in openDb.then()
2016-02-09T18:08:17.201Z - info: before addVertexClasses
2016-02-09T18:08:17.201Z - info: entered addVertexClasses
2016-02-09T18:08:17.202Z - info: in createClass method-psrecdefn
2016-02-09T18:08:17.204Z - info: in createClass method-psdbfield
2016-02-09T18:08:17.204Z - info: testing...
2016-02-09T18:08:17.221Z - info:  , 
2016-02-09T18:08:19.084Z - info: Created class: psrecdefn
2016-02-09T18:08:19.085Z - info:  name=recname, type=STRING
2016-02-09T18:08:19.085Z - info:  name=rectype, type=STRING
2016-02-09T18:08:19.094Z - info: Created class: psdbfield
2016-02-09T18:08:19.095Z - info:  name=fieldname, type=STRING
2016-02-09T18:08:19.095Z - info:  name=fieldtype, type=STRING
2016-02-09T18:08:19.095Z - info:  name=length, type=STRING
2016-02-09T18:08:19.102Z - info: create class for all vertices complete
2016-02-09T18:08:19.103Z - info: addVertexClasses complete
2016-02-09T18:08:19.105Z - info: built sqls successfully
2016-02-09T18:08:19.106Z - info: in processVertices
2016-02-09T18:08:19.107Z - info: in execsql
2016-02-09T18:08:19.107Z - info: in execsql
2016-02-09T18:08:26.018Z - info: 10
2016-02-09T18:15:42.549Z - info: oServer.serverNamelocal
2016-02-09T18:15:42.563Z - info: THE END
2016-02-09T18:15:42.576Z - info: inside oServer.start().then
2016-02-09T18:15:42.653Z - info: found the database:mydb6
2016-02-09T18:15:42.654Z - info: undefined
2016-02-09T18:15:42.656Z - info: in openDb.then()
2016-02-09T18:15:42.659Z - info: before addVertexClasses
2016-02-09T18:15:42.659Z - info: entered addVertexClasses
2016-02-09T18:15:42.661Z - info: in createClass method-psrecdefn
2016-02-09T18:19:16.944Z - info: oServer.serverNamelocal
2016-02-09T18:19:16.951Z - info: THE END
2016-02-09T18:19:16.964Z - info: inside oServer.start().then
2016-02-09T18:19:17.049Z - info: found the database:mydb6
2016-02-09T18:19:17.050Z - info: undefined
2016-02-09T18:19:17.054Z - info: in openDb.then()
2016-02-09T18:19:17.058Z - info: before addVertexClasses
2016-02-09T18:19:17.059Z - info: entered addVertexClasses
2016-02-09T18:19:17.060Z - info: in createClass method-psrecdefn
2016-02-09T18:21:11.952Z - info: oServer.serverNamelocal
2016-02-09T18:21:11.960Z - info: THE END
2016-02-09T18:21:11.971Z - info: inside oServer.start().then
2016-02-09T18:21:12.053Z - info: found the database:mydb6
2016-02-09T18:21:12.054Z - info: undefined
2016-02-09T18:21:12.056Z - info: in openDb.then()
2016-02-09T18:21:12.059Z - info: before addVertexClasses
2016-02-09T18:21:12.059Z - info: entered addVertexClasses
2016-02-09T18:21:12.061Z - info: in createClass method-psrecdefn
2016-02-09T18:23:50.041Z - info: oServer.serverNamelocal
2016-02-09T18:23:50.046Z - info: THE END
2016-02-09T18:23:50.058Z - info: inside oServer.start().then
2016-02-09T18:23:50.131Z - info: found the database:mydb6
2016-02-09T18:23:50.140Z - info:  sessionId=-1, forcePrepare=true, name=mydb6, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["server"]["transport"], $ref=$["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=187, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=394, _bytesDispatched=77, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], _eventsCount=1, _maxListeners=Infinity, type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }
2016-02-09T18:23:50.144Z - info: database created:mydb6
2016-02-09T18:23:50.166Z - info: in openDb.then()
2016-02-09T18:23:50.168Z - info: before addVertexClasses
2016-02-09T18:23:50.168Z - info: entered addVertexClasses
2016-02-09T18:23:50.170Z - info: in createClass method-psrecdefn
2016-02-09T18:23:50.170Z - info: in createClass method-psdbfield
2016-02-09T18:23:50.170Z - info: testing...
2016-02-09T18:23:50.170Z - info: no.of promises=2
2016-02-09T18:23:50.170Z - info: create class for all vertices complete
2016-02-09T18:23:50.171Z - info: addVertexClasses complete
2016-02-09T18:23:50.172Z - info: built sqls successfully
2016-02-09T18:23:50.172Z - info: in processVertices
2016-02-09T18:23:50.173Z - info: in execsql
2016-02-09T18:23:50.173Z - info: in execsql
2016-02-09T18:23:57.421Z - info: 13
2016-02-09T18:24:25.490Z - info: oServer.serverNamelocal
2016-02-09T18:24:25.496Z - info: THE END
2016-02-09T18:24:25.513Z - info: inside oServer.start().then
2016-02-09T18:24:25.588Z - info: database mydb6 not found. Creating one
2016-02-09T18:24:34.441Z - info: created db=mydb6
2016-02-09T18:24:34.463Z - info:  sessionId=189, forcePrepare=true, name=mydb6, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["server"]["transport"], $ref=$["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=189, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=334, _bytesDispatched=110, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], _eventsCount=1, _maxListeners=Infinity, type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }
2016-02-09T18:24:34.469Z - info: database created:mydb6
2016-02-09T18:24:34.503Z - info: in openDb.then()
2016-02-09T18:24:34.507Z - info: before addVertexClasses
2016-02-09T18:24:34.508Z - info: entered addVertexClasses
2016-02-09T18:24:34.510Z - info: in createClass method-psrecdefn
2016-02-09T18:24:34.513Z - info: in createClass method-psdbfield
2016-02-09T18:24:34.513Z - info: testing...
2016-02-09T18:24:34.513Z - info: no.of promises=2
2016-02-09T18:24:36.414Z - info: Created class: psrecdefn
2016-02-09T18:24:36.414Z - info: recname
2016-02-09T18:24:36.414Z - info: STRING
2016-02-09T18:24:36.415Z - info: rectype
2016-02-09T18:24:36.415Z - info: STRING
2016-02-09T18:24:36.430Z - info: Created class: psdbfield
2016-02-09T18:24:36.430Z - info: fieldname
2016-02-09T18:24:36.430Z - info: STRING
2016-02-09T18:24:36.431Z - info: fieldtype
2016-02-09T18:24:36.431Z - info: STRING
2016-02-09T18:24:36.431Z - info: length
2016-02-09T18:24:36.431Z - info: STRING
2016-02-09T18:24:36.440Z - info: create class for all vertices complete
2016-02-09T18:24:36.440Z - info: addVertexClasses complete
2016-02-09T18:24:36.443Z - info: built sqls successfully
2016-02-09T18:24:36.450Z - info: in processVertices
2016-02-09T18:24:36.451Z - info: in execsql
2016-02-09T18:24:36.451Z - info: in execsql
2016-02-09T18:24:41.152Z - info: 10
2016-02-09T18:29:54.119Z - info: oServer.serverNamelocal
2016-02-09T18:29:54.126Z - info: THE END
2016-02-09T18:29:54.143Z - info: inside oServer.start().then
2016-02-09T18:29:54.227Z - info: database mydb6 not found. Creating one
2016-02-09T18:30:02.808Z - info: created db=mydb6
2016-02-09T18:30:02.830Z - info:  sessionId=202, forcePrepare=true, name=mydb6, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["server"]["transport"], $ref=$["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=202, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=334, _bytesDispatched=110, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], _eventsCount=1, _maxListeners=Infinity, type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }
2016-02-09T18:30:02.836Z - info: database created:mydb6
2016-02-09T18:30:02.874Z - info: in openDb.then()
2016-02-09T18:30:02.878Z - info: before addVertexClasses
2016-02-09T18:30:02.878Z - info: entered addVertexClasses
2016-02-09T18:30:02.880Z - info: in createClass method-psrecdefn
2016-02-09T18:30:02.883Z - info: in createClass method-psdbfield
2016-02-09T18:30:02.884Z - info: testing...
2016-02-09T18:30:02.884Z - info: no.of promises=2
2016-02-09T18:30:04.607Z - info: Created class: psrecdefn
2016-02-09T18:30:04.608Z - info: recname
2016-02-09T18:30:04.608Z - info: STRING
2016-02-09T18:30:04.608Z - info: rectype
2016-02-09T18:30:04.609Z - info: STRING
2016-02-09T18:30:04.621Z - info: Created class: psdbfield
2016-02-09T18:30:04.621Z - info: fieldname
2016-02-09T18:30:04.621Z - info: STRING
2016-02-09T18:30:04.622Z - info: fieldtype
2016-02-09T18:30:04.622Z - info: STRING
2016-02-09T18:30:04.623Z - info: length
2016-02-09T18:30:04.623Z - info: STRING
2016-02-09T18:30:06.921Z - info: create class for all vertices complete
2016-02-09T18:30:06.921Z - info: addVertexClasses complete
2016-02-09T18:30:06.923Z - info: built sqls successfully
2016-02-09T18:30:06.924Z - info: in processVertices
2016-02-09T18:30:06.924Z - info: in execsql
2016-02-09T18:30:06.925Z - info: in execsql
2016-02-09T18:30:11.939Z - info: 10
2016-02-09T18:35:08.760Z - info: oServer.serverNamelocal
2016-02-09T18:35:08.768Z - info: THE END
2016-02-09T18:35:08.789Z - info: inside oServer.start().then
2016-02-09T18:35:08.896Z - info: database mydb6 not found. Creating one
2016-02-09T18:35:17.115Z - info: created db=mydb6
2016-02-09T18:35:17.138Z - info:  sessionId=209, forcePrepare=true, name=mydb6, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["server"]["transport"], $ref=$["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=209, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=334, _bytesDispatched=110, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], _eventsCount=1, _maxListeners=Infinity, type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }
2016-02-09T18:35:17.144Z - info: database created:mydb6
2016-02-09T18:35:17.186Z - info: in openDb.then()
2016-02-09T18:35:17.190Z - info: before addVertexClasses
2016-02-09T18:35:17.190Z - info: entered addVertexClasses
2016-02-09T18:35:17.192Z - info: in createClass method-psrecdefn
2016-02-09T18:35:17.195Z - info: in createClass method-psdbfield
2016-02-09T18:35:17.195Z - info: testing...
2016-02-09T18:35:17.196Z - info: no.of promises=2
2016-02-09T18:35:19.004Z - info: Created class: psrecdefn
2016-02-09T18:35:19.021Z - info: Created class: psdbfield
2016-02-09T18:35:20.143Z - info: property created.
2016-02-09T18:35:20.157Z - info: property created.
2016-02-09T18:35:20.158Z - info: create class for all vertices complete
2016-02-09T18:35:20.158Z - info: addVertexClasses complete
2016-02-09T18:35:20.160Z - info: built sqls successfully
2016-02-09T18:35:20.161Z - info: in processVertices
2016-02-09T18:35:20.161Z - info: in execsql
2016-02-09T18:35:20.162Z - info: in execsql
2016-02-09T18:35:24.660Z - info: 10
2016-02-09T18:36:58.304Z - info: oServer.serverNamelocal
2016-02-09T18:36:58.315Z - info: THE END
2016-02-09T18:36:58.331Z - info: inside oServer.start().then
2016-02-09T18:36:58.432Z - info: found the database:mydb6
2016-02-09T18:36:58.444Z - info:  sessionId=-1, forcePrepare=true, name=mydb6, useToken=false, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, reset=function () { [native code] }, _eventsCount=1, _maxListeners=Infinity, _bitField=268566529, _fulfillmentHandler0=undefined, _rejectionHandler0=undefined, _progressHandler0=undefined, _promise0=undefined, _receiver0=undefined, $ref=$["server"]["transport"], $ref=$["server"]["transport"], closing=false, retries=0, maxRetries=5, host=localhost, port=2424, username=root, password=root, enableRIDBags=true, useToken=false, , sessionId=214, error=function () { [native code] }, log=function () { [native code] }, debug=function () {}, domain=null, update-config=function () { [native code] }, reconnectNow=function () { [native code] }, error=function () { [native code] }, _eventsCount=3, _maxListeners=Infinity, host=localhost, port=2424, _connecting=false, _hadError=false, , fd=-1, reading=true, $ref=$["server"]["transport"]["connection"]["socket"], onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // if it's not enough data, we'll just call handle.readStart()
    // again right away.
    self.bytesRead += nread;

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // push a null to signal the end of data.
  self.push(null);

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _parent=null, _host=localhost, objectMode=false, highWaterMark=16384, buffer=[], length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, defaultEncoding=utf8, ranOut=false, awaitDrain=0, readingMore=false, decoder=null, encoding=null, resumeScheduled=false, readable=true, domain=null, close=[function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }, function () { [native code] }], data=function () { [native code] }, error=function () { [native code] }, end=function () { [native code] }, _eventsCount=4, _maxListeners=100, objectMode=false, highWaterMark=16384, needDrain=false, ending=false, ended=false, finished=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=false, bufferProcessing=false, onwrite=function (er) {
    onwrite(stream, er);
  }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, writable=true, allowHalfOpen=false, destroyed=false, bytesRead=394, _bytesDispatched=77, _sockname=null, _pendingData=null, _pendingEncoding=, read=function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true, $ref=$["server"]["transport"]["logger"], enableRIDBags=true, closing=false, reconnectNow=false, Operation=function Operation(data) {
  this.status = Operation.PENDING;
  this.writeOps = [];
  this.readOps = [];
  this.stack = [{}];
  this.data = data || {};
}, OperationQueue=function OperationQueue(socket) {
  this.socket = socket || null;
  this.items = [];
  this.writes = [];
  this.remaining = null;
  if (socket) {
    this.bindToSocket();
  }
  Emitter.call(this);
}, PROTOCOL_VERSION=28, BYTES_LONG=8, BYTES_INT=4, BYTES_SHORT=2, BYTES_BYTE=1, d=100, b=98, f=102, D=100, B=98, F=102, serializeDocument=function serializeDocument(document, isMap) {
  if (typeof document.toOrient === 'function') {
    document = document.toOrient();
  }

  var result = '',
      className = '',
      fieldNames = Object.keys(document),
      totalFields = fieldNames.length,
      fieldWrap, value, field, i;

  for (i = 0; i < totalFields; i++) {
    field = fieldNames[i];
    value = document[field];
    if (field === '@class') {
      className = value;
    }
    else if (field.charAt(0) === '@' || value === undefined) {
      continue;
    }
    else {
      if (isMap) {
        fieldWrap = '"';
      }
      else {
        fieldWrap = '';
      }
      result += fieldWrap + field + fieldWrap + ':' + serializeValue(value) + ',';
    }
  }

  if (className !== '') {
    result = className + '@' + result;
  }

  if (result[result.length - 1] === ',') {
    result = result.slice(0, -1);
  }

  return result;
}, serializeValue=function serializeValue(value) {
  var type = typeof value;
  if (type === 'string') {
    return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
  }
  else if (type === 'number') {
    return ~value.toString().indexOf('.') ? value + 'f' : value;
  }
  else if (type === 'boolean') {
    return value ? true : false;
  }
  else if (Object.prototype.toString.call(value) === '[object Date]') {
    return value.getTime() + 't';
  }
  else if (Array.isArray(value)) {
    return serializeArray(value);
  }
  else if (value === Object(value)) {
    return serializeObject(value);
  }
  else {
    return '';
  }
}, encodeRecordData=function encodeRecordData(content) {
  return new Buffer(serializeDocument(content), 'utf8');
}, enableRIDBags=true, deserialize=function deserialize(input, classes) {
  var record = {'@type': 'd'},
      chunk, key, value;
  if (!input) {
    return null;
  }
  chunk = eatFirstKey(input);
  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }
  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    if (input.charAt(0) === ',') {
      input = input.slice(1);
    }
    else {
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    return classes[record['@class']](record);
  }
  else {
    return record;
  }
}, eatKey=function eatKey(input) {
  var length = input.length,
      collected = '',
      result, c, i;

  if (input.charAt(0) === '"') {
    result = eatString(input.slice(1));
    return [result[0], result[1].slice(1)];
  }

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ':') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatValue=function eatValue(input, classes) {
  var c, n;
  c = input.charAt(0);
  while (c === ' ' && input.length) {
    input = input.slice(1);
    c = input.charAt(0);
  }

  if (!input.length || c === ',') {
    // this is a null field.
    return [null, input];
  }
  else if (c === '"') {
    return eatString(input.slice(1));
  }
  else if (c === '#') {
    return eatRID(input.slice(1));
  }
  else if (c === '[') {
    return eatArray(input.slice(1), classes);
  }
  else if (c === '<') {
    return eatSet(input.slice(1), classes);
  }
  else if (c === '{') {
    return eatMap(input.slice(1), classes);
  }
  else if (c === '(') {
    return eatRecord(input.slice(1), classes);
  }
  else if (c === '%') {
    return eatBag(input.slice(1));
  }
  else if (c === '_') {
    return eatBinary(input.slice(1));
  }
  else if (c === '-' || c === '0' || +c) {
    return eatNumber(input);
  }
  else if (c === 'n' && input.slice(0, 4) === 'null') {
    return [null, input.slice(4)];
  }
  else if (c === 't' && input.slice(0, 4) === 'true') {
    return [true, input.slice(4)];
  }
  else if (c === 'f' && input.slice(0, 5) === 'false') {
    return [false, input.slice(5)];
  }
  else {
    return [null, input];
  }
}, eatString=function eatString(input) {
  var length = input.length,
      collected = '',
      c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '\\') {
      // escape, skip to the next character
      i++;
      collected += input.charAt(i);
      continue;
    }
    else if (c === '"') {
      break;
    }
    else {
      collected += c;
    }
  }

  return [collected, input.slice(i + 1)];
}, eatNumber=function eatNumber(input) {
  var length = input.length,
      collected = '',
      pattern = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/,
      num, c, i;

  num = input.match(pattern);
  if (num) {
    collected = num[0];
    i = collected.length;
  }

  collected = +collected;
  input = input.slice(i);

  c = input.charAt(0);

  if (c === 'a' || c === 't') {
    collected = new Date(collected);
    input = input.slice(1);
  }
  else if (c === 'b' || c === 's' || c === 'l' || c === 'f' || c == 'd' || c === 'c') {
    input = input.slice(1);
  }

  return [collected, input];
}, eatRID=function eatRID(input) {
  var length = input.length,
      collected = '',
      cluster, c, i;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (cluster === undefined && c === ':') {
      cluster = +collected;
      collected = '';
    }
    else if (c === '-' || c === '0' || +c) {
      collected += c;
    }
    else {
      break;
    }
  }

  return [new RID({cluster: cluster, position: +collected}), input.slice(i)];
}, eatArray=function eatArray(input, classes) {
  var length = input.length,
      array = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ']') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    array.push(chunk[0]);
    input = chunk[1];
  }
  return [array, input];
}, eatSet=function eatSet(input, classes) {
  var length = input.length,
      set = [],
      chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '>') {
      input = input.slice(1);
      break;
    }
    chunk = eatValue(input, classes);
    set.push(chunk[0]);
    input = chunk[1];
  }

  return [set, input];
}, eatMap=function eatMap(input, classes) {
  var length = input.length,
      map = {},
      key, value, chunk, c;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === '}') {
      input = input.slice(1);
      break;
    }

    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      map[key] = value;
    }
    else {
      map[key] = null;
    }
  }

  return [map, input];
}, eatRecord=function eatRecord(input, classes) {
  var record = {'@type': 'd'},
      chunk, c, key, value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    else if (c === ')') {
      // empty record.
      input = input.slice(1);
      return [record, input];
    }
    else {
      break;
    }
  }

  chunk = eatFirstKey(input);

  if (chunk[2]) {
    // this is actually a class name
    record['@class'] = chunk[0];
    input = chunk[1];
    chunk = eatKey(input);
    while (input.length) {
      c = input.charAt(0);
      if (c === ' ') {
        input = input.slice(1);
        continue;
      }
      else if (c === ')') {
        // empty record.
        input = input.slice(1);
        return [record, input];
      }
      else {
        break;
      }
    }
    key = chunk[0];
    input = chunk[1];
  }
  else {
    key = chunk[0];
    input = chunk[1];
  }

  // read the first value.
  chunk = eatValue(input, classes);
  value = chunk[0];
  input = chunk[1];
  record[key] = value;

  while (input.length) {
    c = input.charAt(0);
    if (c === ' ') {
      input = input.slice(1);
      continue;
    }
    if (c === ',') {
      input = input.slice(1);
    }
    else if (c === ')') {
      input = input.slice(1);
      break;
    }
    chunk = eatKey(input);
    key = chunk[0];
    input = chunk[1];
    if (input.length) {
      chunk = eatValue(input, classes);
      value = chunk[0];
      input = chunk[1];
      record[key] = value;
    }
    else {
      record[key] = null;
    }
  }

  if (classes && record['@class'] && classes[record['@class']]) {
    record = classes[record['@class']](record);
  }

  return [record, input];
}, eatBag=function eatBag(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === ';') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  if (exports.enableRIDBags) {
    return [new Bag(collected), input];
  }
  else {
    return [new Bag(collected).all(), input];
  }
}, eatBinary=function eatBinary(input) {
  var length = input.length,
      collected = '',
      i, bag, chunk, c;

  for (i = 0; i < length; i++) {
    c = input.charAt(i);
    if (c === '_' || c === ',' || c === ')' || c === '>' || c === '}' || c === ']') {
      break;
    }
    else {
      collected += c;
    }
  }
  input = input.slice(i + 1);

  return [new Buffer(collected, 'base64'), input];
}, connect=function () { return parent.apply(this, arguments); }, db-open=function () { return parent.apply(this, arguments); }, db-create=function () { return parent.apply(this, arguments); }, db-exists=function () { return parent.apply(this, arguments); }, db-delete=function () { return parent.apply(this, arguments); }, db-size=function () { return parent.apply(this, arguments); }, db-countrecords=function () { return parent.apply(this, arguments); }, db-reload=function () { return parent.apply(this, arguments); }, db-list=function () { return parent.apply(this, arguments); }, db-freeze=function () { return parent.apply(this, arguments); }, db-release=function () { return parent.apply(this, arguments); }, db-close=function () { return parent.apply(this, arguments); }, datacluster-add=function () { return parent.apply(this, arguments); }, datacluster-count=function () { return parent.apply(this, arguments); }, datacluster-datarange=function () { return parent.apply(this, arguments); }, datacluster-drop=function () { return parent.apply(this, arguments); }, record-create=function () { return parent.apply(this, arguments); }, record-load=function () { return parent.apply(this, arguments); }, record-metadata=function () { return parent.apply(this, arguments); }, record-update=function () { return parent.apply(this, arguments); }, record-delete=function () { return parent.apply(this, arguments); }, record-clean-out=function () { return parent.apply(this, arguments); }, command=function () { return parent.apply(this, arguments); }, tx-commit=function () { return parent.apply(this, arguments); }, config-list=function () { return parent.apply(this, arguments); }, config-get=function () { return parent.apply(this, arguments); }, config-set=function () { return parent.apply(this, arguments); }, queue=[], writes=[], remaining=null, connecting=false, protocolVersion=32, get=function () { [native code] }, set=function () { [native code] }, list=function () { [native code] }, domain=null, reset=[function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }, function () { [native code] }], _eventsCount=1, _maxListeners=Infinity, type=graph, storage=plocal, token=null, useToken=false, username=admin, password=admin, dataSegments=[], transactionId=0, , , cached=false, list=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, getByName=function () { [native code] }, getById=function () { [native code] }, drop=function () { [native code] }, count=function () { [native code] }, range=function () { [native code] }, cacheData=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, update=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, get=function () { [native code] }, resolveReferences=function () { [native code] }, meta=function () { [native code] }, update=function () { [native code] }, delete=function () { [native code] }, cached=false, list=function () { [native code] }, create=function () { [native code] }, drop=function () { [native code] }, get=function () { [native code] }, cacheData=function () { [native code] }, create=function () { [native code] }, delete=function () { [native code] }, from=function () { [native code] }, to=function () { [native code] }
2016-02-09T18:36:58.448Z - info: database created:mydb6
2016-02-09T18:36:58.475Z - info: in openDb.then()
2016-02-09T18:36:58.478Z - info: before addVertexClasses
2016-02-09T18:36:58.478Z - info: entered addVertexClasses
2016-02-09T18:36:58.480Z - info: in createClass method-psrecdefn
2016-02-09T18:36:58.480Z - info: in createClass method-psdbfield
2016-02-09T18:36:58.480Z - info: testing...
2016-02-09T18:36:58.480Z - info: no.of promises=2
2016-02-09T18:36:58.481Z - info: create class for all vertices complete
2016-02-09T18:36:58.481Z - info: addVertexClasses complete
2016-02-09T18:36:58.482Z - info: built sqls successfully
2016-02-09T18:36:58.482Z - info: in processVertices
2016-02-09T18:36:58.483Z - info: in execsql
2016-02-09T18:36:58.483Z - info: in execsql
2016-02-09T18:37:03.350Z - info: 13
