!*******************************************************************************
!  Program:     DECODEPC.SQR
!  Url:         https://github.com/dlprice/Decode-PeopleCode
!*******************************************************************************
!
!  Programmer:  David L. Price
!
!*******************************************************************************
!
! This program was designed as a learning experiment to help me understand
! better how PeopleSoft stored PeopleCode.
!
! TO DO / KNOWN ISSUES:
! * Indenting is still a work in progress
! * There are still several instances where line feeds aren't correct.  Such
!   as where semi-colons are options (single statement 'if' blocks)
! * Spacing is fairly good.  Semi-colons sometimes get an extra space before them.
!
!*******************************************************************************
!                   SQR Modification Log
!
!    DATE      DESCRIPTION
! ==========   ================================================================
! 12-04-2004   Created for PeopleSoft 8.4x
! 03-14-2005   Added Interactive selection mode.  Enter 'I' at prompt
! 01-23-2006   Added additional command codes.  Fixed break when bad /missing
!              PC is submitted.
! 08-30-2006   Added 'legacy number' command code.  Still needs work.
! 02-03-2010   Added block comment (0x55) and continue command (0x6e)
! 03-11-2011   Added about 9 commands, mostly used in Application Packages.
!              Made changes to the evaluate to handle the large number of breaks.
!              Updated Legacy Number logic to better handle decimals.
! 06-15-2011   Updated Comment commands to handle longs comments (by calling
!              LineFeed whe n 0x0a is encountered), added new commands
! 09-20-2011   Fixed a bunch of stupid spelling mistakes (mostly in comments)
! 10-01-2011   Minor improvements to indention.
!              Removed <brk>.
!              Remove prompting and interactive sessions to optimize writing
!              several PeopleCode objects to file in a row.  You now need to
!              modify the WHERE clause to adjust output.
!              Added ability to skip writing file if it already exists (on by default)
!              Added some additional commands found in 8.51 (implements)
!              Strips invalid characters from filename
! 11-04-2011   Changes to indention logic.
!              Added two more commands per user request: 0x70 (interface) & 0x71 (end-interface)
!              Added 0x6c (Data Type)
! 03-13-2012   8.52 changed PSPCMPROG from a LONG RAW to a BLOB.  Need to remove
!              function to convert LONG RAW to BLOB.
! 06-21-2013   Removed dependency on DLP_PCODE table.  CLOBs are much easier to
!              work with than LONG RAW.  Probably will break all backward
!              compatibility.  Min PeopleTools version likely: 8.52
! 07-18-2014   Added 0x52 (Doc) command
!
!*******************************************************************************

#define TRUE     1
#define FALSE    0

#define SLICE_SIZE  2000             ! 2000 seems to be the maximum for ORACLE
#define INDENT_SIZE 3
#define MAX_OPTIONS 20

!*******************************************************************************
begin-program
!*******************************************************************************

move 'DECODEPC'            to $ReportID
move 'PeopleCode Decoder'  to $ReportTitle
do Init-Report

! Initialize Settings
let #Output_To_File = {TRUE}
let #Skip_If_Exists = {TRUE}
let $Output_Directory = 'c:\temp\stage\'

begin-select distinct
OBJECTVALUE1
OBJECTVALUE2
OBJECTVALUE3
OBJECTVALUE4
OBJECTVALUE5
OBJECTVALUE6
OBJECTVALUE7

   let $WhereClause = 'OBJECTVALUE1 = ''' || &ObjectValue1 || ''' and ' ||
                      'OBJECTVALUE2 = ''' || &ObjectValue2 || ''' and ' ||
                      'OBJECTVALUE3 = ''' || &ObjectValue3 || ''' and ' ||
                      'OBJECTVALUE4 = ''' || &ObjectValue4 || ''' and ' ||
                      'OBJECTVALUE5 = ''' || &ObjectValue5 || ''' and ' ||
                      'OBJECTVALUE6 = ''' || &ObjectValue6 || ''' and ' ||
                      'OBJECTVALUE7 = ''' || &ObjectValue7 || ''''

   let $ObjectName = rtrim(&ObjectValue1 || '.' ||
                           &ObjectValue2 || '.' ||
                           &ObjectValue3 || '.' ||
                           &ObjectValue4 || '.' ||
                           &ObjectValue5 || '.' ||
                           &ObjectValue6 || '.' ||
                           &ObjectValue7  , '. ')

   let #EndOfCode = {FALSE}
   let $CodeLine  = ''
   let $Code      = ''

   let $Indent    = '' ! +: Add one level, -: Remove one level, 0: Reset to zero
   let #Indent    = 0

   if #Output_To_File
      do Open-File
   end-if

   if not (#Output_To_File and #Skip_File)

      let #Program_Segment = 0
      let #Program_Slice   = -1

      ! Get rid of first 37 bytes.  PeopleCode header information.
      ! We might do something with this later.
      let #i = 0
      while #i < 37
         do NextByte(#tVal)
         ! show #tVal edit 099 noline
         ! show ' ' noline
         add 1 to #i
      end-while

      ! Program starts at byte 38
      do NextByte(#tVal)
      while not #end-file
         let $SBefore = 'N'
         !let $SAfter  = 'N'
         ! 'Y' - Space Required
         ! 'N' - Space Not Required
         ! 'P' - Space Required, except next to punctuation: ().,;

         do Evaluate-Return-Value
         if #EndOfCode
            break
         end-if

         do NextByte(#tVal)
      end-while
      do LineFeed

   else
      show '   - Skipped'
   end-if

   if #Output_To_File and not #Skip_File
      close 1
   end-if

from pspcmprog
where lastupdoprid <> 'PPLSOFT'          ! All custom or customized PeopleCode
order by 1,2,3,4,5,6,7
end-select

end-program

!*******************************************************************************
begin-procedure Init-Report
!*******************************************************************************

do Get-Tools-Version($ToolsRel)
do Get-Database-Name($DBName)

show '------------------------------------------------------------------------'
show $ReportTitle
show 'Tools: ' $ToolsRel
show 'Database: ' $DBName
show '------------------------------------------------------------------------'
show ' '

date-time () MM/DD/YYYY  &ReportDate
date-time () HH:MI       &ReportTime

create-array name=Options size={MAX_OPTIONS}
   field=Option:char

create-array name=WhereClause size=16
   field=Item:char

evaluate $sqr-database
   when = 'ORACLE'
      let $Today = 'SYSDATE'
      begin-sql
      ALTER SESSION SET NLS_DATE_FORMAT='DD-MON-YYYY';
      ALTER SESSION SET NLS_DATE_LANGUAGE='AMERICAN';
      end-sql
      break
   when-other
      show ' '
      show '= = = = = = = = = E R R O R = = = = = = = = ='
      show ' '
      show 'Sorry.  Decode PeopleCode currently'
      show 'only works on Oracle.'
      show ' '
      show '= = = = = = = = = = = = = = = = = = = = = = ='
      stop quiet
end-evaluate


end-procedure

!*******************************************************************************
begin-procedure Open-File
!*******************************************************************************
! The record length needs to be longer than just a line since comments are stored
! with built in linefeeds (0x0a).  I suppose I could have called LineFeed when
! these were encountered.  Which, by the way, I finally did in 2011.

let #Skip_File = {FALSE}
let $FileName = nvl($ObjectName,'peoplecode') || '.pc'
let $FileName = $Output_Directory || nvl(translate($ObjectName,'?','_'),'peoplecode') || '.pc'

show 'Output to: ' $FileName

if #Skip_If_Exists and exists($FileName) = 0

   let #Skip_File = {TRUE}

else

   open $FileName as 1
      for-writing
      record=10000:vary
      status=#Open_Error

   if #Open_Error
      show ' '
      show '  *** Unable to open filename ***'
      show ' '
      stop
   end-if

end-if

end-procedure

!*******************************************************************************
begin-procedure Evaluate-Return-Value
!*******************************************************************************
! This list is not conclusive.  There are still gaps.  I can only assume
! that every number has a meaning... but some of these could be for obsolete
! commands and so no longer used.  Currently the program will stop when it
! encounters an unrecognized code.

! Currently the pssqr.ini file delivered by PeopleSoft only allows for 75 breaks.
! This, of course, could be increased, but to keep this as universally usable as
! possible, I am breaking up the evaluate.

if #tVal <= 60
   evaluate #tVal
      when = 1   ! 0x01
          ! Variable Name
          let $SBefore = 'P'
          do Get-String($tString)
          do WriteCode($tString)
          let $SAfter  = 'P'
          break
      when = 3   ! 0x03
          let $SBefore = 'N'
          do WriteCode(',')
          let $SAfter  = 'Y'
          break
      when = 4   ! 0x04
          let $SBefore = 'Y'
          do WriteCode('/')
          let $SAfter  = 'Y'
          break
      when = 5   ! 0x05
          let $SBefore = 'N'
          do WriteCode('.')
          let $SAfter  = 'N'
          break
      when = 6   ! 0x06
          let $SBefore = 'Y'
          do WriteCode('=')
          let $SAfter  = 'Y'
          break
      when = 7   ! 0x07
          ! End of Code
          let #EndOfCode = {TRUE}
          break
      when = 8   ! 0x08
          let $SBefore = 'Y'
          do WriteCode('>=')
          let $SAfter  = 'Y'
          break
      when = 9   ! 0x09
          let $SBefore = 'Y'
          do WriteCode('>')
          let $SAfter  = 'Y'
          break
      when = 10  ! 0x0a
          ! Function / Method / External Datatype / Class Name
          let $SBefore = 'P'
          do Get-String($tString)
          do WriteCode($tString)
          let $SAfter  = 'P'
          break
      when = 11  ! 0x0b
          let $SBefore = 'N'
          do WriteCode('(')
          let $SAfter  = 'N'
          break
      when = 12  ! 0x0c
          let $SBefore = 'Y'
          do WriteCode('<=')
          let $SAfter  = 'Y'
          break
      when = 13  ! 0x0d
          let $SBefore = 'Y'
          do WriteCode('<')
          let $SAfter  = 'Y'
          break
      when = 14  ! 0x0e
          let $SBefore = 'Y'
          do WriteCode('-')
          let $SAfter  = 'Y'
          break
      when = 15  ! 0x0f
          let $SBefore = 'Y'
          do WriteCode('*')
          let $SAfter  = 'Y'
          break
      when = 16  ! 0x10
          let $SBefore = 'Y'
          do WriteCode('<>')
          let $SAfter  = 'Y'
          break
      when = 17  ! 0x11
          ! Number (Legacy?  no longer used?)
          let $SBefore = 'P'
          do Get-Legacy-Number($tVal)
          do WriteCode($tVal)
          let $SAfter  = 'P'
          break
      when = 18  ! 0x12
          ! System Variable Name
          let $SBefore = 'P'
          do Get-String($tString)
          do WriteCode($tString)
          let $SAfter  = 'P'
          break
      when = 19  ! 0x13
          let $SBefore = 'Y'
          do WriteCode('+')
          let $SAfter  = 'Y'
          break
      when = 20  ! 0x14
          let $SBefore = 'N'
          do WriteCode(')')
          let $SAfter  = 'N'
          break
      when = 21  ! 0x15
          let $SBefore = 'N'
          do WriteCode(';')
          do LineFeed
          let $SAfter  = 'N'
          break
      when = 22  ! 0x16
          ! Quoted Literal
          let $SBefore = 'P'
          do Get-String($tString)
          let $tString = '"' || $tString || '"'
          do WriteCode($tString)
          let $SAfter  = 'P'
          break
      when = 24  ! 0x18
          let $SBefore = 'Y'
          do WriteCode('And')
          do LineFeed
          let $SAfter  = 'Y'
          break
      when = 25  ! 0x19
          let $SBefore = 'Y'
          do SetIndent('-+')
          do WriteCode('Else')
          do LineFeed
          let $SAfter  = 'Y'
          break
      when = 26  ! 0x1a
          let $SBefore = 'Y'
          do SetIndent('-')
          do WriteCode('End-If')
          let $SAfter  = 'P'
          !do LineFeed  ! Should have a semi-colon and not require a linefeed
          break
      when = 27  ! 0x1b
          let $SBefore = 'Y'
          do WriteCode('Error')
          let $SAfter  = 'Y'
          break
      when = 28  ! 0x1c
          let $SBefore = 'Y'
          do SetIndent('+')
          do WriteCode('If')
          let $SAfter  = 'Y'
          break
      when = 29  ! 0x1d
          let $SBefore = 'Y'
          do WriteCode('Not')
          let $SAfter  = 'Y'
          break
      when = 30  ! 0x1e
          let $SBefore = 'Y'
          do WriteCode('Or')
          do LineFeed
          let $SAfter  = 'Y'
          break
      when = 31  ! 0x1f
          let $SBefore = 'Y'
          do WriteCode('Then')
          do LineFeed
          let $SAfter  = 'Y'
          break
      when = 32  ! 0x20
          let $SBefore = 'Y'
          do WriteCode('Warning')
          let $SAfter  = 'Y'
          break
      when = 33  ! 0x21
          ! PeopleSoft object indicator (w/ Object name)
          let $SBefore = 'P'
          do NextByte(#Byte1)
          do NextByte(#Byte2) ! could be the high order byte of NAMENUM
          do Get-Object-Reference(#Byte1,$Recname, $Refname)
          let $out = $Recname || '.' || $Refname
          do WriteCode($out)
          let $SAfter  = 'P'
          break
      when = 35  ! 0x23
          let $SBefore = 'Y'
          do WriteCode('|')
          let $SAfter  = 'Y'
          break
      when = 36  ! 0x24
          ! Comment
          do NextByte(#lCommentLength1)
          do NextByte(#lCommentLength2)
          let #lCommentLength = (#lCommentLength2 * 256) + #lCommentLength1
             let #i = 0
          while #i < #lCommentLength
             do NextByte(#tVal)
             if #tVal = 10
               do LineFeed
             else
               let $out = chr(#tVal)
               do WriteCode($out)
             end-if
             do NextByte(#tVal)
             add 2 to #i
          end-while
          do LineFeed
          break
      when = 37  ! 0x25
          let $SBefore = 'Y'
          do SetIndent('+')
          do WriteCode('While')
          let $SAfter  = 'Y'
          break
      when = 38  ! 0x26
          let $SBefore = 'Y'
          do SetIndent('-')
          do WriteCode('End-While')
          let $SAfter  = 'Y'
          break
      when = 39  ! 0x27
          let $SBefore = 'Y'
          do SetIndent('+')
          do WriteCode('Repeat')
          do LineFeed
          let $SAfter  = 'Y'
          break
      when = 40  ! 0x28
          let $SBefore = 'Y'
          do SetIndent('-')
          do WriteCode('Until')
          let $SAfter  = 'Y'
          break
      when = 41  ! 0x29
          let $SBefore = 'Y'
          do SetIndent('+')
          do WriteCode('For')
          let $SAfter  = 'Y'
          break
      when = 42  ! 0x2a
          let $SBefore = 'Y'
          do WriteCode('To')
          let $SAfter  = 'Y'
          break
      when = 43  ! 0x2b
          let $SBefore = 'Y'
          do WriteCode('Step')
          let $SAfter  = 'Y'
          break
      when = 44
          let $SBefore = 'Y'
          do SetIndent('-')
          do WriteCode('End-For')
          let $SAfter  = 'Y'
          break
      when = 45  ! 0x2d
          ! Code Section Separator.  Not sure exactly what this is for,
          ! so I am writing it out to maybe be able to spot a pattern
          ! do WriteCode('<brk>')
          ! do WriteCode('=====================================================================================')
          do LineFeed
          break
      when = 46  ! 0x2e
          let $SBefore = 'Y'
          do WriteCode('Break')
          let $SAfter  = 'Y'
          break
      when = 47  ! 0x2f
          let $SBefore = 'Y'
          do WriteCode('True')
          let $SAfter  = 'Y'
          break
      when = 48  ! 0x30
          let $SBefore = 'Y'
          do WriteCode('False')
          let $SAfter  = 'Y'
          break
      when = 49  ! 0x31
          do SetIndent('0')
          let $SBefore = 'Y'
          do WriteCode('Declare')
          let $SAfter  = 'Y'
          break
      when = 50  ! 0x32
          let $SBefore = 'Y'
          do SetIndent('+')
          do WriteCode('Function')
          let $SAfter  = 'Y'
          break
      when = 51  ! 0x33
          let $SBefore = 'Y'
          do WriteCode('Library')
          let $SAfter  = 'Y'
          break
      when = 53  ! 0x35
          let $SBefore = 'Y'
          do WriteCode('As')
          let $SAfter  = 'Y'
          break
      when = 54  ! 0x36
          let $SBefore = 'Y'
          do WriteCode('Value')
          let $SAfter  = 'Y'
          break
      when = 55  ! 0x37
          let $SBefore = 'Y'
          do SetIndent('-')
          do WriteCode('End-Function')
          let $SAfter  = 'P'
          break
      when = 56  ! 0x38
          let $SBefore = 'Y'
          do WriteCode('Return')
          let $SAfter  = 'Y'
          break
      when = 57  ! 0x39
          let $SBefore = 'Y'
          do WriteCode('Returns')
          let $SAfter  = 'Y'
          break
      when = 58  ! 0x3a
          let $SBefore = 'Y'
          do WriteCode('PeopleCode')
          let $SAfter  = 'Y'
          break
      when = 59  ! 0x3b
          let $SBefore = 'Y'
          do WriteCode('Ref')
          let $SAfter  = 'Y'
          break
      when = 60  ! 0x3c
          let $SBefore = 'Y'
          do WriteCode('Evaluate')
          let $SAfter  = 'Y'
          break
      when-other
          show ''
          show '**************'
          show 'CodeLine: ' $Codeline
          show 'Unknown:'  #tVal
          stop
          break
   end-evaluate

else  ! #tVal >= 61

    evaluate #tVal
       when = 61  ! 0x3d
           let $SBefore = 'Y'
           do WriteCode('When')
           let $SAfter  = 'Y'
           break
       when = 62  ! 0x3e
           let $SBefore = 'Y'
           do WriteCode('When-Other')
           let $SAfter  = 'Y'
           break
       when = 63  ! 0x3f
           let $SBefore = 'Y'
           do WriteCode('End-Evaluate')
           let $SAfter  = 'Y'
           break
       when = 64  ! 0x40
           ! PeopleCode Variable Type Name
           let $SBefore = 'P'
           do Get-String($tString)
           do WriteCode($tString)
           let $SAfter  = 'P'
           break
       when = 65  ! 0x41
           ! Parmlist
           break
       when = 66  ! 0x42
           ! End Parmlist / End of Declare Statement
           break
       when = 67  ! 0x43
           let $SBefore = 'Y'
           do WriteCode('Exit')
           let $SAfter  = 'Y'
           break
       when = 68  ! 0x44
           let $SBefore = 'Y'
           do WriteCode('Local')
           let $SAfter  = 'Y'
           break
       when = 69  ! 0x45
           let $SBefore = 'Y'
           do WriteCode('Global')
           let $SAfter  = 'Y'
           break
       when = 70  ! 0x46
           let $SBefore = 'Y'
           do WriteCode('**')
           let $SAfter  = 'Y'
           break
       when = 71  ! 0x47
           let $SBefore = 'N'
           do WriteCode('@')
           let $SAfter  = 'N'
           break
       when = 72  ! 0x48
           ! PeopleSoft object indicator (w/ object name)
           let $SBefore = 'P'
           do NextByte(#Byte1)
           do NextByte(#Byte2) ! could be the high order byte of namenum
           do Get-Object-Reference(#Byte1,$Recname, $Refname)
           let $out = $RecName || '."' || $Refname || '"'
           do WriteCode($out)
           let $SAfter  = 'P'
           break
       when = 73  ! 0x49
           let $SBefore = 'Y'
           do WriteCode('set')
           let $SAfter = 'P'
           break
       when = 74  ! 0x4a
           ! PeopleSoft object indicator (w/o object name)
           let $SBefore = 'P'
           do NextByte(#Byte1)
           do NextByte(#Byte2) ! could be the high order byte of namenum
           do Get-Object-Reference(#Byte1,$Recname, $Refname)
           do WriteCode($Refname)
           let $SAfter  = 'P'
           break
       when = 75  ! 0x4b
           let $SBefore = 'Y'
           do WriteCode('Null')
           let $SAfter  = 'Y'
           break
       when = 76  ! 0x4c
           let $SBefore = 'Y'
           do WriteCode('[')
           let $SAfter  = 'N'
           break
       when = 77  ! 0x4d
           let $SBefore = 'N'
           do WriteCode(']')
           let $SAfter  = 'Y'
           break
       when = 78  ! 0x4e
           ! Inline Code - Not really working since I have \n after certain commands
           ! Comment
           let $SBefore = 'Y'
           do NextByte(#lCommentLength1)
           do NextByte(#lCommentLength2)
           let #lCommentLength = (#lCommentLength2 * 256) + #lCommentLength1

           let #i = 0
           while #i < #lCommentLength
              do NextByte(#tVal)
              let $out = chr(#tVal)
              do WriteCode($out)
              do NextByte(#tVal)
              add 2 to #i
           end-while
           let $SAfter = 'N'
           do LineFeed
           break
       when = 79  ! 0x4f
           ! Blank Line
           do LineFeed
           break
       when = 80  ! 0x50
           ! Number
           let $SBefore = 'P'
           do Get-Number($tVal)
           do WriteCode($tVal)
           let $SAfter  = 'P'
           break
       when = 81  ! 0x51
           let $SBefore = 'Y'
           do WriteCode('PanelGroup')
           let $SAfter = 'Y'
           break
       when = 83  ! 0x52
           let $SBefore = 'Y'
           do WriteCode('Doc')
           let $SAfter = 'Y'
           break
       when = 84  ! 0x54
           let $SBefore = 'Y'
           do WriteCode('Component')
           let $SAfter = 'Y'
           break
       when = 85  ! 0x55
           ! Block Comment <*  *>
           do NextByte(#lCommentLength1)
           do NextByte(#lCommentLength2)
           let #lCommentLength = (#lCommentLength2 * 256) + #lCommentLength1

           let #i = 0
           while #i < #lCommentLength
              do NextByte(#tVal)
              if #tVal = 10
                do LineFeed
              else
                let $out = chr(#tVal)
                do WriteCode($out)
              end-if
              do NextByte(#tVal)
              add 2 to #i
           end-while
           do LineFeed
           break
       when = 86  ! 0x56
           let $SBefore = 'Y'
           do WriteCode('Constant')
           let $SAfter = 'Y'
           break
       when = 87  ! 0x57
           let $SBefore = 'N'
           do WriteCode(':')
           let $SAfter = 'N'
           break
       when = 88  ! 0x58
           let $SBefore = 'Y'
           do WriteCode('import')
           let $SAfter = 'Y'
           break
       when = 89  ! 0x59
           let $SBefore = 'N'
           do WriteCode('*')
           let $SAfter = 'N'
           break
       when = 90  ! 0x5a
           let $SBefore = 'Y'
           do WriteCode('class')
           let $SAfter = 'Y'
           break
       when = 91  ! 0x5b
           let $SBefore = 'Y'
           do WriteCode('end-class')
           let $SAfter = 'Y'
           break
       when = 92  ! 0x5c
           let $SBefore = 'Y'
           do WriteCode('extends')
           let $SAfter = 'Y'
           break
       when = 93  ! 0x5d
           let $SBefore = 'Y'
           do WriteCode('out')
           let $SAfter = 'P'
           break
       when = 94  ! 0x5e
           let $SBefore = 'Y'
           do WriteCode('property')
           let $SAfter = 'Y'
           break
       when = 95  ! 0x5f
           let $SBefore = 'Y'
           do WriteCode('get')
           let $After = 'P'
           break
       when = 96  ! 0x60
           let $SBefore = 'Y'
           do WriteCode('readonly')
           let $After = 'P'
           break
       when = 97  ! 0x61
           let $SBefore = 'Y'
           do WriteCode('private')
           do LineFeed
           let $SAfter = 'Y'
           break
       when = 98  ! 0x62
           let $SBefore = 'Y'
           do WriteCode('instance')
           let $SAfter = 'Y'
           break
       when = 99  ! 0x63
           let $SBefore = 'Y'
           do WriteCode('method')
           let $SAfter = 'Y'
           break
       when = 100 ! 0x64
           let $SBefore = 'Y'
           do WriteCode('end-method')
           let $SAfter = 'Y'
           break
       when = 101 ! 0x65
           let $SBefore = 'Y'
           do WriteCode('try')
           do LineFeed
           let $SAfter  = 'Y'
           break
       when = 102 ! 0x66
           let $SBefore = 'Y'
           do WriteCode('catch')
           let $SAfter  = 'Y'
           break
       when = 103 ! 0x67
           let $SBefore = 'Y'
           do WriteCode('end-try')
           let $SAfter  = 'Y'
           break
       when = 104 ! 0x68
           let $SBefore = 'Y'
           do WriteCode('throw')
           let $SAfter = 'Y'
           break
       when = 105 ! 0x69
           let $SBefore = 'Y'
           do WriteCode('create')
           let $SAfter  = 'Y'
           break
       when = 106 ! 0x6a
           let $SBefore = 'Y'
           do WriteCode('end-get')
           let $SAfter = 'Y'
           break
       when = 107 ! 0x6b
           let $SBefore = 'Y'
           do WriteCode('end-set')
           let $SAfter = 'Y'
           break
       when = 108 ! 0x6c
           ! Data Type
           let $SBefore = 'Y'
           do Get-String($tString)
           do WriteCode($tString)
           let $SAfter = 'Y'
           break
       when = 109 ! 0x6d
           let $SBefore = 'Y'
           do WriteCode('/+ ')
           do Get-String($tString)
           do WriteCode($tString)
           do WriteCode(' +/')
           let $SAfter  = 'Y'
           do LineFeed
           break
       when = 110 ! 0x6e
           let $SBefore = 'Y'
           do WriteCode('continue')
           let $SAfter  = 'Y'
           break
       when = 111 ! 0x6f
           let $SBefore = 'Y'
           do WriteCode('abstract')
           let $SAfter  = 'Y'
           break
       when = 112 ! 0x70
           let $SBefore = 'Y'
           do WriteCode('interface')
           let $SAfter = 'Y'
           break
       when = 113 ! 0x71
           let $SBefore = 'Y'
           do WriteCode('end-interface')
           let $SAfter = 'Y'
           break
       when = 114 ! 0x72
           let $SBefore = 'Y'
           do WriteCode('implements')
           let $SAfter = 'Y'
           break
       when = 115 ! 0x73
           let $SBefore = 'Y'
           do WriteCode('protected')
           let $SAfter  = 'Y'
           do LineFeed
           break
       when-other
           show ''
           show '**************'
           show 'CodeLine: ' $Codeline
           show 'Unknown:'  #tVal
           stop
           break
   end-evaluate

end-if

end-procedure

!*******************************************************************************
begin-procedure NextByte (:#tVal)
!*******************************************************************************
! Pulls off the first two characters from the $Code string that represent a
! hexadecimal value and converts them to a numeric value.  If the $Code string
! is empty (e.g., when all of the two byte values have been processed), it will
! call the Get-Next-Segment function to return the next slice.

while isblank($_Code)
   do Get-Next-Segment($_Code)
end-while
let $tVal1 = substr($_Code,1,1)
let $tVal2 = substr($_Code,2,1)
let $_Code = substr($_Code,3,length($_Code))

do HexToDec($tVal1)
do HexToDec($tVal2)
let #tVal = (16 * to_number($tVal1)) + to_number($tVal2)

end-procedure

!*******************************************************************************
begin-procedure Get-Next-Segment (:$inCode)
!*******************************************************************************
! First increment the Slice to get the next 2000 bytes from the current Segment.
! If there is no more data in the current Segment, check the next Segment,
! starting with the first Slice (= 0).

add 1 to #_Program_Slice

let $inCode = ''
let #offset = ({SLICE_SIZE} * #_Program_Slice) + 1

begin-select
PROGSEQ
Dbms_Lob.SubStr(PROGTXT,{SLICE_SIZE},#offset) &PROGTXT

   let $inCode = &PROGTXT

FROM PSPCMPROG
WHERE [$_WhereClause]
AND PROGSEQ = #_Program_Segment
end-select

if isnull(&PROGSEQ)
   show '**ERROR** No additional code found'
   show '   Program Name: ' $_ProgName
   show '   Program Seg : ' #_Program_Segment
   show '   PROGSEQ     : ' &PROGSEQ
   stop
end-if

if isblank($inCode)
   add 1 to #_Program_Segment
   let #_Program_Slice = -1
end-if

end-procedure

!*******************************************************************************
begin-procedure HexToDec(:$in_char)
!*******************************************************************************
! Crude Hex to Decimal conversion

let $TestChar = lower($in_char)
evaluate $TestChar
   when = 'a'
      let $in_char = '10'
      break
   when = 'b'
      let $in_char = '11'
      break
   when = 'c'
      let $in_char = '12'
      break
   when = 'd'
      let $in_char = '13'
      break
   when = 'e'
      let $in_char = '14'
      break
   when = 'f'
      let $in_char = '15'
      break
end-evaluate

end-procedure

!*******************************************************************************
begin-procedure SetIndent($inChar)
!*******************************************************************************
! Rudimentary Indenting logic.  Probably will expand later.

if $_Indent <> '0'
  let $_Indent = $inChar
end-if

end-procedure


!*******************************************************************************
begin-procedure WriteCode($inChar)
!*******************************************************************************
! Separate function so I can expand the functionality.  I think I am going
! to have to do something here to get the spacing right.
!
! 'Y' : Make sure a space exists before/after code item
! 'N' : Do not add space before/after code item
! 'P' : Make sure a space exists before/after code item, unless between punctuation

let $LastChar = substr($_CodeLine,length($_CodeLine),1)

if $_CodeLine <> ''
   if ($_SAfter = 'Y' and $LastChar <> ' ') or ($_SAfter = 'P' and instr(' ().;,[]', substr($inChar,1,1), 0) = 0)
      let $_CodeLine = $_CodeLine || ' '
      let $LastChar = ' '
   end-if

   if ($_SBefore = 'Y' and $LastChar <> ' ') or ($_SBefore = 'P' and instr(' ().;,[]', $LastChar, 0) = 0)
      let $_CodeLine = $_CodeLine || ' '
   end-if
end-if

let $_CodeLine = $_CodeLine || $inChar

let $_SAfter  = 'N'
let $_SBefore = 'N'

end-procedure

!*******************************************************************************
begin-procedure LineFeed
!*******************************************************************************
! $Indent
!   '+' : Add indent to next line
!   '-' : Subtract indent from current line
!   '-+': Remove indention level, then add to next line
!   Note: only one indention level can exist
!

if $Indent = '-' or $Indent = '-+'
   subtract {INDENT_SIZE} from #Indent
end-if

if $Indent = '0'
   let #Indent = 0
end-if

let $out = lpad('', #Indent, ' ')
let $CodeLine = $out || $CodeLine

if #Output_To_File
   write 1 from $CodeLine
else
   show $CodeLine
end-if

if $Indent = '+' or $Indent = '-+'
   add {INDENT_SIZE} to #Indent
end-if

let $CodeLine = ''
let $Indent = ''

end-procedure

!*******************************************************************************
begin-procedure Get-String(:$out_String)
!*******************************************************************************
! PeopleCode strings characters are stored as two byte characters.  With the
! standard ASCII, only the first byte is used.  I have not bothered trying to
! support this yet since we are using just ASCII.  I am reading the first byte,
! and then just junking the second byte (reading, but doing nothing).

let $out_String = ''
do NextByte(#tVal)
while #tVal <> 0
   let $out_String = $out_String || chr(#tVal)
   do NextByte(#tVal) ! Junk 00 byte
   do NextByte(#tVal)
end-while
do NextByte(#tVal) ! Junk 00 byte

end-procedure

!*******************************************************************************
begin-procedure Get-Number(:$out_Number)
!*******************************************************************************
! This doesn't seem to be able to handle very large numbers.  For example,
! in my PeopleCode program I have 312345678901234567890123456789012, but this
! function returns the value      312345678901235007690186929282860.  Not sure
! why the rounding issue.  Maybe an SQR limitation?  SQR is supposed to be able
! to handle large values.  Need to look into later.  Fortunately we don't deal
! with numbers this large in HR very often.

declare-variable
   decimal #tValue(37)
end-declare

let #tValue = 0.0

! Not sure what the first bytes is for.  So far it is always
! 0x000. It is not used for negative.  Chomp for now.
do NextByte(#tVal)

do NextByte(#Decimal)

! Numbers are stored Low Order first
let #i = 0
while #i < 16
   do NextByte(#tVal)
   let #tValue = #tValue + ( ( 256 ^ #i ) * #tVal )
   ! show #i edit 99 noline
   ! show ': ' #tVal edit 99 noline
   ! show '= ' #tValue
   add 1 to #i
end-while

let #tValue = #tValue / (10 ^ #Decimal)

let $out_number = to_char(#tValue)

end-procedure

!*******************************************************************************
begin-procedure Get-Legacy-Number(:$out_Number)
!*******************************************************************************
! Code 0x11 (17) seems to be only used in older code.  Any attempts to
! recreated this generates an 0x50 (80)... which is the regular number.
! Without multiple examples, it is next to impossible to determine how this is
! stored.  Until I can, I will list examples here.
!
! 11 0000 0000 8000 0000 0000 0000 0000 = 128
! 11 0000 0000 0100 0000 0000 0000 0000 = 1
! 11 0000 0200 9f86 0100 0000 0000 0000 = 999.99

declare-variable
   decimal #tValue(37)
end-declare

let #tValue = 0.0
let #Decimal = 0

! Assume it is something like the current number..

! Skipping first 2 bytes... not sure what they are for.
do NextByte(#tVal)
if #tVal <> 0
   show ''
   show '***************'
   show 'Legacy Number: First byte non-zero'
   show 'tVal = ' #tVal
   show 'CodeLine = ' $_CodeLine
   stop
end-if

do NextByte(#tVal)
if #tVal <> 0
   show ''
   show '***************'
   show 'Legacy Number: Second byte non-zero'
   show 'tVal = ' #tVal
   show 'CodeLine = ' $_CodeLine
   stop
end-if

! Decimal precision seems to be stored in the 3rd byte.  Might also
! be using the 4th byte, however that would required more than 256
! values after the decimal.  Not sure that happens often.
do NextByte(#Decimal)

! Skipping fourth byte... not sure what it is for.
do NextByte(#tVal)
if #tVal <> 0
   show ''
   show '***************'
   show 'Legacy Number: Fourth byte non-zero'
   show 'tVal = ' #tVal
   show 'CodeLine = ' $_CodeLine
   stop
end-if

! Numbers are stored Low Order first
let #i = 0
while #i < 10
   do NextByte(#tVal)
   let #tValue = #tValue + ( ( 256 ^ #i ) * #tVal )
   ! show #i edit 99 noline
   ! show ': ' #tVal edit 99 noline
   ! show '= ' #tValue
   add 1 to #i
end-while

let #tValue = #tValue / (10 ^ #Decimal)

let $out_number = to_char(#tValue)

! I'm pretty confident about these values... so I will let them pass.
! Anything outside of this range should be examined.  Will remove this
! section if I ever get a better understanding of these numbers
if #tValue < 0 or #tValue > 99999999
   show ''
   show '**************'
   show 'New Legacy Number found'
   show 'Calculated at:'  #tValue
   stop
end-if

end-procedure

!*******************************************************************************
begin-procedure Get-Object-Reference(#in_NameNum,:$out_Recname,:$out_Refname)
!*******************************************************************************
! For some reason, the number referenced in the PeopleCode is one less than
! the NAMENUM.  Hence the '+1' in the WHERE clause.

let $out_Recname = 'Unknown'
let $out_Refname = 'Unknown'

begin-select
RECNAME
REFNAME

   let $out_Recname = &RECNAME
   let $out_RefName = &REFNAME

from PSPCMNAME
where [$_WhereClause]
and   NAMENUM = #in_NameNum + 1
end-select

end-procedure

!*******************************************************************************
begin-procedure Get-Tools-Version(:$ToolsRel)
!*******************************************************************************
! Valid Return values: pre-7, 7, 7.5, 8, 8.4

! This is not really used in this program.  I use this when trying to write
! something for multiple version.  See PAGEINFO.sqr, for example.

let $ToolsVersionTable = ''
let $ToolsRel = ''

begin-select
RECNAME

   let $ToolsVersionTable = &RECNAME

from PSRECFIELD
where FIELDNAME = 'TOOLSREL'
and RECNAME in ('PSLOCK','PSSTATUS')
end-select

if not isblank($ToolsVersionTable)
begin-select
TOOLSREL

   let $ToolsRel = &TOOLSREL

from [$ToolsVersionTable]
end-select
end-if


end-procedure

!*******************************************************************************
begin-procedure Get-Database-Name(:$DBName)
!*******************************************************************************

let $DBName = 'Unknown'

! Get Database Name
begin-select loops=1
DBNAME

   let $DBName = &DBNAME

from ps.psdbowner
where upper(OWNERID) = upper($_username)
end-select

end-procedure

!*******************************************************************************
begin-procedure Prompt-User
!*******************************************************************************
! Basic usage is that you enter the object list of where the peoplecode resides,
! separating each object with a period.
! Examples: JOB.EMPLID.SaveEdit
!
! Alternate prompt values:
!   . = Skip importing PeopleCode
!   / = Set options
!   > = Interactive Mode
!

The_Beginning:

let $WhereClause  = ''

input $InputMask 'Enter Search (''?'' for instructions)'
if isblank($InputMask)
   show ' '
   show 'Ending Program.'
   stop quiet
end-if

! uppercase $InputMask
let $TestChar = substr($InputMask,1,1)
evaluate $TestChar
when = '>'
   do Interactive-Mode ($ObjectName, $WhereClause)
   break
when = '.'
   ! Skip Importing PeopleCode.  This will run whatever
   ! is already in staging table.
   let $WhereClause = ''
   break
!when = '@'
!   do Process-FileList
!   if isblank($WhereClause)
!      goto The_Beginning
!   end-if
!   break
!when = '?'
!   do Show-Instructions
!   goto The_Beginning
!   break
when = '/'
   ! Configuration Options
   let $InputMask = ltrim($InputMask, '/')
   evaluate $InputMask
   when = '*'
      show ' '
      show '  == Current Settings =='
      show '  Output to File      : ' noline
      do Show-True-Or-False(#Output_To_File)
      !show '  Print Field Numbers : ' noline
      !do Show-True-Or-False(#Print_Field_Num)
      show ' '
      break
   when = 'O'
      let #Output_To_File = not #Output_To_File
      show ' '
      if #Output_To_File
         show '=== Output To File ==='
      else
         show '=== Output To Screen ==='
      end-if
      show ' '
      break
   !when = 'F'
   !   let #Print_Field_Num = not #Print_Field_Num
   !   show ' '
   !   if #Print_Field_Num
   !      show '=== Print Field Number ==='
   !   else
   !      show '=== Suppress Field Number ==='
   !   end-if
   !   show ' '
   !   break
   when-other
      show ' '
      show ' *** Valid Options ***'
      show ' /O = Toggle Output Destination'
      show ' /* = List Option values'
      show ' '
      break
   end-evaluate
   goto The_Beginning
   break
when-other
   unstring $InputMask
      by '.'
      into $ObjectValue1
           $ObjectValue2
           $ObjectValue3
           $ObjectValue4
           $ObjectValue5
           $ObjectValue6
           $ObjectValue7

   let $ObjectValue1 = nvl(ltrim(rtrim($ObjectValue1,' '),' '),' ')
   let $ObjectValue2 = nvl(ltrim(rtrim($ObjectValue2,' '),' '),' ')
   let $ObjectValue3 = nvl(ltrim(rtrim($ObjectValue3,' '),' '),' ')
   let $ObjectValue4 = nvl(ltrim(rtrim($ObjectValue4,' '),' '),' ')
   let $ObjectValue5 = nvl(ltrim(rtrim($ObjectValue5,' '),' '),' ')
   let $ObjectValue6 = nvl(ltrim(rtrim($ObjectValue6,' '),' '),' ')
   let $ObjectValue7 = nvl(ltrim(rtrim($ObjectValue7,' '),' '),' ')

   let $WhereClause = 'OBJECTVALUE1 = ''' || $ObjectValue1 || ''' and ' ||
                      'OBJECTVALUE2 = ''' || $ObjectValue2 || ''' and ' ||
                      'OBJECTVALUE3 = ''' || $ObjectValue3 || ''' and ' ||
                      'OBJECTVALUE4 = ''' || $ObjectValue4 || ''' and ' ||
                      'OBJECTVALUE5 = ''' || $ObjectValue5 || ''' and ' ||
                      'OBJECTVALUE6 = ''' || $ObjectValue6 || ''' and ' ||
                      'OBJECTVALUE7 = ''' || $ObjectValue7 || ''''

   let $ObjectName = rtrim($ObjectValue1 || '.' ||
                           $ObjectValue2 || '.' ||
                           $ObjectValue3 || '.' ||
                           $ObjectValue4 || '.' ||
                           $ObjectValue5 || '.' ||
                           $ObjectValue6 || '.' ||
                           $ObjectValue7  , '. ')
   break
end-evaluate

show ' '
show 'Processing....'

end-procedure

!*******************************************************************************
begin-procedure Show-True-Or-False(#in_evaluate)
!*******************************************************************************

if #in_evaluate
   show 'YES'
else
   show 'NO'
end-if

end-procedure

!*******************************************************************************
begin-procedure Interactive-Mode (:$ObjectName, :$WhereClause)
!*******************************************************************************
! Trying to remember the name of a PeopleCode object isn't so bad when you are
! only talking about Record PeopleCode, but it gets much worse when working with
! App Engines.  I threw this "Interactive Mode" together to (1) help me find
! PeopleCode, and (2) to play with some ideas I had.

! PeopleCode is stored in as seven paired values.  Each pair drills down deeper
! to identify the specific PeopleCode object.  Some PeopleCode types only require
! three pairs (RecField PeopleCode, for example, only needs Record name, Field
! name, and PeopleCode Type), while others require all seven (i.e., Application
! Engine PeopleCode).  The first value in each pair represents an Object Type
! (Record, Page, Component, etc.), the second is the Object Name.

! This program cycles through each field (7 pairs x 2 per pair = 14 fields),
! assisting the user along the way.  If there is only one value value (determined
! by a SELECT UNIQUE), that value is used.  If there are less than MAX_OPTIONS
! choices, the user will be presented with a list to choose from.  If there are
! more, the user will be prompted to enter a object mask (i.e., JOB%) to limit
! the number returned until less than MAX_OPTIONS are found.

show '================'
show 'Interactive Mode'
show '================'

let $WhereClause     = ''
let $ObjectMask      = ''
let $Current_ID_Type = ''
let $ObjectName      = ''
clear-array name=WhereClause

let #i = 1
while #i <= 7
   let #j = 1
   while #j <= 2
      if #j = 1
         let $ObjectType = 'ID'
      else
         let $ObjectType = 'VALUE'
      end-if

      do Select-Values(#i, $ObjectType, $ObjectMask, #Num_Returned)
      let $ObjectMask = ''
      if #j = 1
         ! nothing
      else
         let $Current_ID_Type = WhereClause.Item(( (#i - 1) * 2 )+ 1)
         do GetObjectType($Current_ID_Type, $Current_ID_Type)
      end-if

      evaluate #Num_Returned
         when = 0
            show ' '
            show 'No ' $Current_ID_Type ' objects found with that mask.'
            show 'Re-enter ' $Current_ID_Type ' mask to broaden ' noline
            input $ObjectMask 'search'
            break
         when = 1
            let WhereClause.Item(((#i - 1) * 2) + #j) = Options.Option(0)
            if #j = 2 and $Current_ID_Type <> '0'
               let $ObjectName = $ObjectName || Options.Option(0) || '.'
               show ' '
               show 'Only 1 ' $Current_ID_Type ' found: ' $ObjectName
            end-if
            add 1 to #j
            break
         when <= {MAX_OPTIONS}
            while {TRUE}
               show ' '
               if #j = 1
                  show 'Select PeopleCode Type:'
               else
                  show 'Select ' $Current_ID_Type ' name:'
               end-if
               let #k = 0
               while #k < #Num_Returned
                  show #k edit 999 noline
                  show ') ' noline
                  let $out = Options.Option(#k)
                  if #j = 1
                     do GetObjectType($out,$out)
                  end-if
                  show $out
                  add 1 to #k
               end-while
               input $InputMask 'Enter Choice'
               let $InputMask = rtrim(ltrim($InputMask,' '),' ')
               if isnull(rtrim($InputMask,'0123456789'))
                  if to_number($InputMask) < #Num_Returned
                     break
                  end-if
               end-if
               show ' '
               show '** Invalid option.  Please choose again.'
            end-while
            let WhereClause.Item(((#i - 1) * 2) + #j) = Options.Option(to_number($InputMask))
            if #j = 1
               ! Do Nothing
            else
               let $ObjectName = $ObjectName || Options.Option(to_number($InputMask)) || '.'
            end-if
            add 1 to #j
            break
         when-other
            show ' '
            show 'More than {MAX_OPTIONS} ' $Current_ID_Type ' objects found.'
            show 'Enter ' $Current_ID_Type ' mask to narrow ' noline
            input $ObjectMask 'search'
            break
      end-evaluate
   end-while
   add 1 to #i
end-while

do Build-WhereClause (7, 2, $WhereClause)
let $ObjectName = rtrim($ObjectName, '. ')

end-procedure

!*******************************************************************************
begin-procedure Select-Values (#IDIndex, $ObjectType, $ObjectMask, :#Num_Returned)
!*******************************************************************************
! #IDIndex = 1..7
! $ObjectType: ID or VALUE

clear-array name=Options

! Build Where clause up to before the current field.
if $ObjectType = 'ID'
   let #out = #IDIndex - 1
   do Build-WhereClause(#out, 2, $WhereClause)
   let $Field = 'to_char(OBJECTID' || edit(#IDIndex,'9') || ')'
else
   do Build-WhereClause (#IDIndex, 1, $WhereClause)
   let $Field = 'OBJECTVALUE' || edit(#IDIndex,'9')
end-if

if not isblank($ObjectMask)
   let $WhereClause = $WhereClause || ' and OBJECT' || $ObjectType || edit(#IDIndex,'9') || ' like ''' || $ObjectMask || ''''
end-if

let #Num_Returned = 0
begin-select distinct
[$Field]  &rf=char

   if #Num_Returned < {MAX_OPTIONS}
      let Options.Option(#Num_Returned) = &rf
   end-if
   add 1 to #Num_Returned

FROM pspcmprog
where [$WhereClause]
end-select

end-procedure

!*******************************************************************************
begin-procedure Build-WhereClause (#MaxJ, #MaxK, :$WhereClause)
!*******************************************************************************
! j = Index
! k = Type

let $WhereClause = ''

let #j = 1
while #j <= #MaxJ
   let #k = 1
   while (#k <= 2 and #j < #MaxJ) or #k <= #MaxK
      if not isblank($WhereClause )
         let $WhereClause = $WhereClause || ' and '
      end-if
      if #k = 1
         let $WhereObject = 'ID'
      else
         let $WhereObject = 'VALUE'
      end-if
      let $WhereClause = $WhereClause || 'OBJECT' || $WhereObject || edit(#j,'9') || ' = ''' || WhereClause.Item(((#j - 1) * 2) + #k) || ''''
      add 1 to #k
   end-while
   add 1 to #j
end-while

if isblank($WhereClause)
   let $WhereClause = '1=1'
end-if

end-procedure

!*******************************************************************************
begin-procedure GetObjectType($in, :$out)
!*******************************************************************************
! There are additional object types that are not in this list, but this seems
! to be all of the ones used as PeopleCode types.  This list might need to
! be expanded later.

evaluate $in
  when = '1'
    let $out = 'Record'
    break
  when = '2'
    let $out = 'Field'
    break
  when = '3'
    let $out = 'Menu'
    break
  when = '4'
    let $out = 'Bar'
    break
  when = '5'
    let $out = 'Menu Item'
    break
  when = '9'
    let $out = 'Page'
    break
  when = '10'
    let $out = 'Component'
    break
  when = '12'
    let $out = 'PeopleCode Type'
    break
  when = '20'
    let $out = 'Platform'
    break
  when = '21'
    let $out = 'Effective Date'
    break
  when = '39'
    let $out = 'Market'
    break
  when = '60'
    let $out = 'Message'
    break
  when = '66'
    let $out = 'Application Engine'
    break
  when = '74'
    let $out = 'Component Interface'
    break
  when = '77'
    let $out = 'Application Section'
    break
  when = '78'
    let $out = 'Step'
    break
  when = '87'
    let $out = 'Message Subscription'
    break
  when = '104'
    let $out = 'Application Package'
    break
  when = '105'
    let $out = '2nd Level Application Package'
    break
  when = '106'
    let $out = '3rd Level Application Package'
    break
  when = '107'
    let $out = 'Application Class'
    break
  when-other
    let $out = $in
    break
end-evaluate

end-procedure